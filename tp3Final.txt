diff --git a/TP3.md b/TP3.md
new file mode 100644
index 0000000..49871f4
--- /dev/null
+++ b/TP3.md
@@ -0,0 +1,313 @@
+TP3.md
+======
+
+
+static_assert:
+-------------
+La macro static_assert de JOS utiliza las comprobaciones regulares del compilador C para hacer un chequeo. Si a la macro se le pasa el valor de x, y este es FALSO (0), entonces generará un error que no se generará si el valor de x es VERDADERO, 1 o cualquier otro número.
+
+
+env_return:
+----------
+Env_run() es la función encargada de llamar a env_pop_tf() que le cede el control al usuario.
+Una vez en el userspace, el programa comienza a ejecutarse desde el símbolo "start", que se ocupa de cargar (o verificar que estén) los argumentos y pasa a ejecutarse la función libmain, en la que se invoca a umain y cuando ésta termina se llama a la función exit(). Exit llama a sys_env_destroy para "matar" al proceso.
+
+
+En el trabajo práctico anterior (TP2), env_destroy() ejecutaba a env_free() y automáticamente llamaba al monitor() de Jos. En este nuevo TP, env_destroy() va a ejecutar sched_yield(), que se encargará de seguir ejecutando el resto de los procesos en estado RUNNABLE (o bien, cederle el control al monitor() de Jos).
+
+
+sys_yield:
+---------
+
+nicolas@nicolas-PC:~/sisop$ make qemu-nox
++ cc kern/init.c
++ ld obj/kern/kernel
++ mk obj/kern/kernel.img
+***
+*** Use Ctrl-a x to exit qemu
+***
+qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp:127.0.0.1:26000 -D qemu.log -smp 1  -d guest_errors
+6828 decimal is 15254 octal!
+Physical memory: 131072K available, base = 640K, extended = 130432K
+boot_alloc memory at f0278000
+Next memory at f0279000
+boot_alloc memory at f0279000
+Next memory at f02b9000
+npages: 32768
+npages_basemem: 160
+pages: f0279000
+boot_alloc memory at f02b9000
+Next memory at f02d8000
+indice MPENTRY_PADDR: 7
+indice npages_basemem: 160
+boot_alloc memory at f02d8000
+Next memory at f02d8000
+pageinfo size: 8
+f02b9000
+med=728
+boot_alloc memory at f02d8000
+Next memory at f02d8000
+check_page_free_list() succeeded!
+check_page_alloc() succeeded!
+check_page() succeeded!
+check_kern_pgdir() succeeded!
+boot_alloc memory at f02d8000
+Next memory at f02d8000
+check_page_free_list() succeeded!
+check_page_installed_pgdir() succeeded!
+SMP: CPU 0 found 1 CPU(s)
+enabled interrupts: 1 2
+[00000000] new env 00001000
+[00000000] new env 00001001
+[00000000] new env 00001002
+Hello, I am environment 00001000.
+Hello, I am environment 00001001.
+Hello, I am environment 00001002.
+Back in environment 00001000, iteration 0.
+Back in environment 00001001, iteration 0.
+Back in environment 00001002, iteration 0.
+Back in environment 00001000, iteration 1.
+Back in environment 00001001, iteration 1.
+Back in environment 00001002, iteration 1.
+Back in environment 00001001, iteration 2.
+Back in environment 00001002, iteration 2.
+Back in environment 00001000, iteration 2.
+Back in environment 00001001, iteration 3.
+Back in environment 00001002, iteration 3.
+Back in environment 00001000, iteration 3.
+Back in environment 00001001, iteration 4.
+All done in environment 00001001.
+[00001001] exiting gracefully
+[00001001] free env 00001001
+Back in environment 00001000, iteration 4.
+All done in environment 00001000.
+[00001000] exiting gracefully
+[00001000] free env 00001000
+Back in environment 00001002, iteration 4.
+All done in environment 00001002.
+[00001002] exiting gracefully
+[00001002] free env 00001002
+No runnable environments in the system!
+Welcome to the JOS kernel monitor!
+Type 'help' for a list of commands.
+K> 
+
+El código del archivo user/yield.c recorre un ciclo y llama a la función sys_yield() un total de 4 veces, devolviéndole el control al Kernel.
+Al modificar i386_init() para crear tres ambientes que corran este programa, la salida obtenida es la esperada: los 3 ambientes se crean, se ejecutan en orden y van llamando por primera vez a sys_yield: primero lo hace el primer ambiente (env_id = 00001000), luego el segundo (env_id = 00001001) y por último el tercero (env_id = 00001002), todos ellos dejando el control casi inmediatamente.
+Entonces el scheduler va a ir devolviéndole el control a cada uno en el mismo orden. Primero, volverá el primer ambiente a finalizar la primera iteración del ciclo, entrará en la segunda y devolverá la ejecución al kernel; éste se la entregará al segundo ambiente que finalizará la primera iteración, entrará en la segunda y devolverá la ejecución al kernel; etc.
+Ésta salida evidencia que el Scheduler implementa el algoritmo de scheduling conocido como Round-Robin.
+
+
+envid2env:
+---------
+
+En Jos, si un proceso llama sys_env_destroy(0), entonces éste buscará el environment correspondiente al id que recibió por parámetro (en este caso, el environment 0). Al comenzar la ejecución de sys_env_destroy() hay una comparación: si el parámetro recibido es 0, entonces se devolverá el environment actual (*curenv*).
+En Linux, si un proceso llama a kill(0,9), el primer argumento (pid_t pid) al ser 0 especifica que se envía el mensaje signal (en este caso 9) a todos los procesos del "process group" del proceso que llamó al wrapper de la syscall.
+
+De igual manera, en Jos, sys_get_env_destroy(-1) devolverá el error -E_BAD_ENV ya que un ambiente en Jos no puede tener id negativo
+En Linux, la llamada kill(-1, 9) le envía la señal 9 a todos aquellos procesos a los que el proceso que invoco al wrapper TIENE PERMISO para enviarle la señal (a excepción del proceso 1, es decir init).
+
+
+dumbfork:
+--------
+
+1. Si la página se reserva entre UTEXT y char* end[], entonces al llamar a dumbfork() se propagará la copia al proceso hijo (mediante duppage()).
+
+2. 
+El estado de solo lectura no se preserva. La función duppage setea los bits de presencia, usuario y escritura. Esto es necesario, para poder realizar la copia de una página a la otra.
+	void* algunPuntero;
+	pte_t pageTable = uvpt[PGNUM(algunPuntero)];
+	if(*pageTable & PTE_W)
+		return true;
+	else
+		return false;*
+
+
+3. La función duppage() literalmente duplica una página que es del padre, y la copia en el proceso hijo. En primer lugar reserva una página nueva (utilizando la misma dirección virtual que le corresponde en el espacio de direcciones del padre), luego la mappea en la dirección UTEMP de su propio espacio de direcciones.
+Por último, una vez ahí copia el contenido de la página en UTEMP de manera tal que queda copiado en el espacio de direcciones del proceso hijo. Por último, *desmappea* la página de UTEMP.
+
+4.  Si el booleano fuera true, entonces debería controlar el valor de perm con una estructura del tipo condicional. De ésta manera, los permisos incluirían o no el PTE_W, respectivamente.
+
+Si quisiéramos poder definir a la página como solo-lectura sin aumentar el número de llamadas al sistema, el algoritmo descripto en el punto anterior funcionaría.
+
+
+5. La dirección addr corresponde al tope del stack. Se hace ROUNDDOWN() para obtener el valor de comienzo de la página en cuestión. Esto es antinatural porque el stack crece para abajo (desde la dirección más alta de la página a la menos alta)
+
+
+
+multicore_init:
+--------------
+
+1. La línea de código mencionada carga en memoria baja (una dirección virtual V en la que está mappeada la dirección física MPENTRY_ADDR, es decir 0x7000) parte del código escrito en el archivo mpentry.S. Analogamente a lo que sucede con el bootloader en boot.S , las application processor (o AP) bootean en real mode pero con la ventaja de que podemos realizar un mapeo que nos simplifique la ejecución del código.
+
+2. La variable global mpentry_kstack apunta al tope de la dirección del Kernel Stack de cada uno de los CPUs.
+En kern/entry.S, código que es ejecutado por una CPU, se setea el stack pointer al final del código mismo. Esto solo podría realizarse desde mpentry.S si todos los CPUs compartieran el mismo stack, y esto no funcionaría ya que al recibir interrupciones en simultáneo se pisaría la información de cada uno de los CPUs.
+
+3. 
+nicolas@nicolas-PC:~/sisop$ make gdḅ 
+~
+(gdb) watch mpentry_kstack
+Hardware watchpoint 1: mpentry_kstack
+(gdb) c
+Continuando.
+Se asume que la arquitectura objetivo es i386
+=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
+
+Thread 1 hit Hardware watchpoint 1: mpentry_kstack
+
+Old value = (void *) 0x0
+New value = (void *) 0xf0249000 <percpu_kstacks+65536>*
+boot_aps () at kern/init.c:112
+112			lapic_startap(c->cpu_id, PADDR(code));
+
+(gdb) bt
+#0  boot_aps () at kern/init.c:112
+#1  0xf010020f in i386_init () at kern/init.c:55
+#2  0xf0100047 in relocated () at kern/entry.S:88
+
+(gdb) info threads
+  Id   Target Id         Frame 
+* 1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
+  2    Thread 2 (CPU#1 [halted ]) 0x000fd412 in ?? ()
+  3    Thread 3 (CPU#2 [halted ]) 0x000fd412 in ?? ()
+  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
+
+(gdb) c
+Continuando.
+=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
+
+Thread 1 hit Hardware watchpoint 1: mpentry_kstack
+
+Old value = (void *) 0xf0249000 <percpu_kstacks+65536>
+New value = (void *) 0xf0251000 <percpu_kstacks+98304>
+boot_aps () at kern/init.c:112
+112			lapic_startap(c->cpu_id, PADDR(code));
+#
+(gdb) info threads
+  Id   Target Id         Frame 
+  1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
+  2    Thread 2 (CPU#1 [running]) 0xf010027f in mp_main () at kern/init.c:130
+  3    Thread 3 (CPU#2 [halted ]) 0x000fd412 in ?? ()
+  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
+#
+(gdb) thread 2
+[Switching to thread 2 (Thread 2)]
+#0  0xf010027f in mp_main () at kern/init.c:130
+130		xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
+#
+(gdb) bt
+#0  0xf010027f in mp_main () at kern/init.c:130
+#1  0x00007060 in ?? ()
+#
+(gdb) p cpunum()
+Could not fetch register "orig_eax"; remote failure reply 'E14'
+1  // Deducido
+#
+(gdb) thread 1
+[Switching to thread 1 (Thread 1)]
+#0  boot_aps () at kern/init.c:112
+112			lapic_startap(c->cpu_id, PADDR(code));
+#
+(gdb) p cpunum()
+Could not fetch register "orig_eax"; remote failure reply 'E14'
+0  // Deducido
+#
+(gdb) c
+Continuando.
+=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
+
+Thread 1 hit Hardware watchpoint 1: mpentry_kstack
+
+Old value = (void *) 0xf0251000 <percpu_kstacks+98304>
+New value = (void *) 0xf0259000 <percpu_kstacks+131072>
+boot_aps () at kern/init.c:112
+112			lapic_startap(c->cpu_id, PADDR(code));
+
+(gdb) info threads
+  Id   Target Id         Frame 
+* 1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
+  2    Thread 2 (CPU#1 [running]) 0xf010027f in mp_main () at kern/init.c:130
+  3    Thread 3 (CPU#2 [running]) 0xf010027f in mp_main () at kern/init.c:130
+  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
+(gdb) 
+
+
+4. mpentry.S se ejecuta en cada una de las CPUs. Se empieza a ejecutar en la dirección virtual mapeada a la dirección física 0x7000, que al estar ejecutándose en Real Mode resulta ser la misma dirección (0x7000)
+
+La ejecución no se detiene al poner un breakpoint en mpentry_start porque el valor del símbolo en sí nada tiene que ver con el del instruction pointer.
+
+5. nicolas@nicolas-PC:~/sisop$ make gdb ~
+
+(gdb) b *0x7000 thread 4
+Punto de interrupción 1 at 0x7000
+(gdb) c
+Continuando.
+
+Thread 2 received signal SIGTRAP, Trace/breakpoint trap.
+[Cambiando a Thread 2]
+Se asume que la arquitectura objetivo es i8086
+[ 700:   0]    0x7000:	cli    
+0x00000000 in ?? ()
+
+(gdb) p $eip
+$1 = (void (*)()) 0x0
+
+(gdb) disable 1
+
+(gdb) si 10
+Se asume que la arquitectura objetivo es i386
+=> 0x7020:	mov    $0x10,%ax
+0x00007020 in ?? ()
+
+(gdb) x/10i $eip
+=> 0x7020:	mov    $0x10,%ax
+   0x7024:	mov    %eax,%ds
+   0x7026:	mov    %eax,%es
+   0x7028:	mov    %eax,%ss
+   0x702a:	mov    $0x0,%ax
+   0x702e:	mov    %eax,%fs
+   0x7030:	mov    %eax,%gs
+   0x7032:	mov    $0x11f000,%eax
+   0x7037:	mov    %eax,%cr3
+   0x703a:	mov    %cr4,%eax
+
+(gdb) watch $eax == 0x11f000
+Watchpoint 2: $eax == 0x11f000
+
+(gdb) c
+Continuando.
+=> 0x7037:	mov    %eax,%cr3
+
+Thread 2 hit Watchpoint 2: $eax == 0x11f000
+
+Old value = 0
+New value = 1
+0x00007037 in ?? ()
+
+(gdb) p $eip
+$2 = (void (*)()) 0x7037
+
+(gdb) p mpentry_kstack
+$3 = (void *) 0x0
+
+(gdb) si 8
+=> 0x704e:	mov    0xf0237f04,%esp
+0x0000704e in ?? ()
+
+(gdb) p mpentry_kstack
+$5 = (void *) 0xf0249000 <percpu_kstacks+65536>
+
+
+
+ipc_recv:
+--------------
+
+
+Dado que queremos enviar el valor numerico -E_INVAL, r siempre va a ser negativo (ya sea porque dio un error o porque efectivamente devolvimos -E_INVAL).
+Entonces, en la version A, tenemos que fijarnos el valor src ya que esta variable valdra 0 en caso de que ipc_recv haya fallado.
+
+Version A:
+  if( src == 0)
+    puts("HUbo error.")
+
+En la version B esto no es posible ya que como primer parametro de la funcion ipc_recv le pasamos NULL por lo que no podemos obtener esta informacion extra.
diff --git a/__pycache__/gradelib.cpython-36.pyc b/__pycache__/gradelib.cpython-36.pyc
index b0eb354..36b69b1 100644
Binary files a/__pycache__/gradelib.cpython-36.pyc and b/__pycache__/gradelib.cpython-36.pyc differ
diff --git a/entregaIncompleta_tp3.diff b/entregaIncompleta_tp3.diff
new file mode 100644
index 0000000..70478d6
--- /dev/null
+++ b/entregaIncompleta_tp3.diff
@@ -0,0 +1,1019 @@
+diff --git a/TP3.md b/TP3.md
+new file mode 100644
+index 0000000..fbd1311
+--- /dev/null
++++ b/TP3.md
+@@ -0,0 +1,303 @@
++TP3.md
++======
++
++
++static_assert:
++-------------
++
++
++
++env_return:
++----------
++
++// HAY UNA RESPUESTA EN EL GRUPO que se llama Duda env_return QUE RESPONDE ESTO
++
++Env_run() es la función encargada de llamar a env_pop_tf() que le cede el control al usuario. Cuando un proceso de usuario terminó de ejecutarse, entonces se llama a la función trap() por medio de ¿¿¿¿¿¿¿la int 0x30?????, ésta función llama a trap_dispatch() que a su vez ejecuta la syscall correspondiente. En éste caso, como el proceso ya terminó de ejecutarse el parámetro syscallno almacenará el valor de la constante SYS_env_destroy. 
++Luego de la syscall, cuando trap_dispatch() finalice y la ejecución llegue a trap(), el kernel verifica que el proceso que se está corriendo ya no está en estado de ENV_RUNNING, por lo que llama a la función sched_yield(), la cual aún no está implementada y al final llama a sched_halt que interrumpe la CPU porque no hay nada para hacer hasta que el timer la despierte.
++
++En el trabajo práctico anterior (TP2), env_destroy() ejecutaba a env_free() y automáticamente llamaba al monitor() de Jos. En este nuevo TP, sched_yield() se encargará de seguir ejecutando otros procesos cuando el actual sea liberado.
++
++sys_yield:
++---------
++
++nicolas@nicolas-PC:~/sisop$ make qemu-nox
+++ cc kern/init.c
+++ ld obj/kern/kernel
+++ mk obj/kern/kernel.img
++***
++*** Use Ctrl-a x to exit qemu
++***
++qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp:127.0.0.1:26000 -D qemu.log -smp 1  -d guest_errors
++6828 decimal is 15254 octal!
++Physical memory: 131072K available, base = 640K, extended = 130432K
++boot_alloc memory at f0278000
++Next memory at f0279000
++boot_alloc memory at f0279000
++Next memory at f02b9000
++npages: 32768
++npages_basemem: 160
++pages: f0279000
++boot_alloc memory at f02b9000
++Next memory at f02d8000
++indice MPENTRY_PADDR: 7
++indice npages_basemem: 160
++boot_alloc memory at f02d8000
++Next memory at f02d8000
++pageinfo size: 8
++f02b9000
++med=728
++boot_alloc memory at f02d8000
++Next memory at f02d8000
++check_page_free_list() succeeded!
++check_page_alloc() succeeded!
++check_page() succeeded!
++check_kern_pgdir() succeeded!
++boot_alloc memory at f02d8000
++Next memory at f02d8000
++check_page_free_list() succeeded!
++check_page_installed_pgdir() succeeded!
++SMP: CPU 0 found 1 CPU(s)
++enabled interrupts: 1 2
++[00000000] new env 00001000
++[00000000] new env 00001001
++[00000000] new env 00001002
++Hello, I am environment 00001000.
++Hello, I am environment 00001001.
++Hello, I am environment 00001002.
++Back in environment 00001000, iteration 0.
++Back in environment 00001001, iteration 0.
++Back in environment 00001002, iteration 0.
++Back in environment 00001000, iteration 1.
++Back in environment 00001001, iteration 1.
++Back in environment 00001002, iteration 1.
++Back in environment 00001001, iteration 2.
++Back in environment 00001002, iteration 2.
++Back in environment 00001000, iteration 2.
++Back in environment 00001001, iteration 3.
++Back in environment 00001002, iteration 3.
++Back in environment 00001000, iteration 3.
++Back in environment 00001001, iteration 4.
++All done in environment 00001001.
++[00001001] exiting gracefully
++[00001001] free env 00001001
++Back in environment 00001000, iteration 4.
++All done in environment 00001000.
++[00001000] exiting gracefully
++[00001000] free env 00001000
++Back in environment 00001002, iteration 4.
++All done in environment 00001002.
++[00001002] exiting gracefully
++[00001002] free env 00001002
++No runnable environments in the system!
++Welcome to the JOS kernel monitor!
++Type 'help' for a list of commands.
++K> 
++
++El código del archivo user/yield.c recorre un ciclo y llama a la función sys_yield() un total de 4 veces, devolviéndole el control al Kernel.
++Al modificar i386_init() para crear tres ambientes que corran este programa, la salida obtenida es la esperada: los 3 ambientes se crean, se ejecutan en orden y van llamando por primera vez a sys_yield: primero lo hace el primer ambiente (env_id = 00001000), luego el segundo (env_id = 00001001) y por último el tercero (env_id = 00001002), todos ellos dejando el control casi inmediatamente.
++Entonces el scheduler va a ir devolviéndole el control a cada uno en el mismo orden. Primero, volverá el primer ambiente a finalizar la primera iteración del ciclo, entrará en la segunda y devolverá la ejecución al kernel; éste se la entregará al segundo ambiente que finalizará la primera iteración, entrará en la segunda y devolverá la ejecución al kernel; etc.
++Ésta salida evidencia que el Scheduler implementa el algoritmo de scheduling conocido como Round-Robin.
++
++
++envid2env:
++---------
++
++En Jos, si un proceso llama sys_env_destroy(0), entonces éste buscará el environment correspondiente al id que recibió por parámetro (en este caso, el environment 0). Al comenzar la ejecución de sys_env_destroy() hay una comparación: si el parámetro recibido es 0, entonces se devolverá el environment actual (*curenv*).
++En Linux, si un proceso llama a kill(0,9), el primer argumento (pid_t pid) al ser 0 especifica que se envía el mensaje signal (en este caso 9) a todos los procesos del "process group" del proceso que llamó al wrapper de la syscall.
++
++De igual manera, en Jos, sys_get_env_destroy(-1) devolverá el error -E_BAD_ENV ya que un ambiente en Jos no puede tener id negativo
++En Linux, la llamada kill(-1, 9) le envía la señal 9 a todos aquellos procesos a los que el proceso que invoco al wrapper TIENE PERMISO para enviarle la señal (a excepción del proceso 1, es decir init).
++
++
++dumbfork:
++--------
++
++1. Si la página se reserva entre UTOP y char* end (lo que sucederá), entonces al llamar a dumbfork() se propagará la copia al proceso hijo.
++2. 
++// No sé bien si se preserva el estado de sólo lectura. sys_page_map() chequea esto para no copiar con permisos de escritura una página de sólo lectura. Pero en este caso debiera devolver un número negativo y resultaría en un panic, y no está pasando...
++//
++
++El estado de solo lectura no se preserva. La función duppage setea los bits de presencia, usuario y escritura. Esto es necesario, para poder realizar la copia de una página a la otra.
++	void* algunPuntero;
++	pde_t pageDir = uvpd[PDX(algunPuntero)];
++	pte_t pageTable = uvpt[PTX(algunPuntero)];
++	if(*pageTable & PTE_W)
++		return true;
++	else
++		return false;*
++
++
++3. La función duppage() literalmente duplica una página que es del padre, y la copia en el proceso hijo. En primer lugar reserva una página nueva (utilizando la misma dirección virtual que le corresponde en el espacio de direcciones del padre), luego la mappea en la dirección UTEMP de su propio espacio de direcciones.
++Por último, una vez ahí copia el contenido de la página en UTEMP de manera tal que queda copiado en el espacio de direcciones del proceso hijo. Por último, *desmappea* la página de UTEMP.
++
++4.  Si el booleano fuera true, entonces debería hacerse una llamada adicional de 
++
++	Si quisiéramos poder definir a la página como solo-lectura sin aumentar el número de llamadas al sistema podríamos acceder al valor almacenado en la pte_t* para la dirección en cuestión y ahí setear "a mano" el bit de escritura (PTE_W) en cero.
++
++5. 
++
++
++
++multicore_init:
++--------------
++
++1. La línea de código mencionada carga en memoria baja (una dirección virtual V en la que está mappeada la dirección física MPENTRY_ADDR, es decir 0x7000) parte del código escrito en el archivo mpentry.S. Analogamente a lo que sucede con el bootloader en boot.S , las application processor (o AP) bootean en real mode pero con la ventaja de que podemos realizar un mapeo que nos simplifique la ejecución del código.
++
++2. ¿Para qué se usa la variable global mpentry_kstack? ¿Qué ocurriría si el espacio para este stack se reservara en el archivo kern/mpentry.S, de manera similar a bootstack en el archivo kern/entry.S?
++
++La variable global mpentry_kstack apunta al tope de la dirección del Kernel Stack de cada uno de los CPUs.
++En kern/entry.S, código que es ejecutado por una CPU, se setea el stack pointer al final del código mismo. Esto solo podría realizarse desde mpentry.S si todos los CPUs compartieran el mismo stack, y esto no funcionaría ya que al recibir interrupciones en simultáneo se pisaría la información de cada uno de los CPUs.
++
++3. 
++nicolas@nicolas-PC:~/sisop$ make gdḅ 
++~
++(gdb) watch mpentry_kstack
++Hardware watchpoint 1: mpentry_kstack
++(gdb) c
++Continuando.
++Se asume que la arquitectura objetivo es i386
++=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
++
++Thread 1 hit Hardware watchpoint 1: mpentry_kstack
++
++Old value = (void *) 0x0
++New value = (void *) 0xf0249000 <percpu_kstacks+65536>*
++boot_aps () at kern/init.c:112
++112			lapic_startap(c->cpu_id, PADDR(code));
++
++(gdb) bt
++#0  boot_aps () at kern/init.c:112
++#1  0xf010020f in i386_init () at kern/init.c:55
++#2  0xf0100047 in relocated () at kern/entry.S:88
++
++(gdb) info threads
++  Id   Target Id         Frame 
++* 1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
++  2    Thread 2 (CPU#1 [halted ]) 0x000fd412 in ?? ()
++  3    Thread 3 (CPU#2 [halted ]) 0x000fd412 in ?? ()
++  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
++
++(gdb) c
++Continuando.
++=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
++
++Thread 1 hit Hardware watchpoint 1: mpentry_kstack
++
++Old value = (void *) 0xf0249000 <percpu_kstacks+65536>
++New value = (void *) 0xf0251000 <percpu_kstacks+98304>
++boot_aps () at kern/init.c:112
++112			lapic_startap(c->cpu_id, PADDR(code));
++
++(gdb) info threads
++  Id   Target Id         Frame 
++  1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
++  2    Thread 2 (CPU#1 [running]) 0xf010027f in mp_main () at kern/init.c:130
++  3    Thread 3 (CPU#2 [halted ]) 0x000fd412 in ?? ()
++  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
++
++(gdb) thread 2
++[Switching to thread 2 (Thread 2)]
++#0  0xf010027f in mp_main () at kern/init.c:130
++130		xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
++
++(gdb) bt
++#0  0xf010027f in mp_main () at kern/init.c:130
++#1  0x00007060 in ?? ()
++
++(gdb) p cpunum()
++
++-------------------------- FALTA
++
++(gdb) thread 1
++[Switching to thread 1 (Thread 1)]
++#0  boot_aps () at kern/init.c:112
++112			lapic_startap(c->cpu_id, PADDR(code));
++
++(gdb) p cpunum()
++
++-------------------------- FALTA
++
++(gdb) c
++Continuando.
++=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
++
++Thread 1 hit Hardware watchpoint 1: mpentry_kstack
++
++Old value = (void *) 0xf0251000 <percpu_kstacks+98304>
++New value = (void *) 0xf0259000 <percpu_kstacks+131072>
++boot_aps () at kern/init.c:112
++112			lapic_startap(c->cpu_id, PADDR(code));
++
++(gdb) info threads
++  Id   Target Id         Frame 
++* 1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
++  2    Thread 2 (CPU#1 [running]) 0xf010027f in mp_main () at kern/init.c:130
++  3    Thread 3 (CPU#2 [running]) 0xf010027f in mp_main () at kern/init.c:130
++  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
++(gdb) 
++
++
++4. mpentry.S se ejecuta en cada una de las CPUs. Se empieza a ejecutar en la dirección virtual mapeada con 0x7000 en dir física.
++
++La ejecución no se detiene al poner un breakpoint en mpentry_start porque jajajajajajsss
++
++5. nicolas@nicolas-PC:~/sisop$ make gdb ~
++
++(gdb) b *0x7000 thread 4
++Punto de interrupción 1 at 0x7000
++(gdb) c
++Continuando.
++
++Thread 2 received signal SIGTRAP, Trace/breakpoint trap.
++[Cambiando a Thread 2]
++Se asume que la arquitectura objetivo es i8086
++[ 700:   0]    0x7000:	cli    
++0x00000000 in ?? ()
++
++(gdb) p $eip
++$1 = (void (*)()) 0x0
++
++(gdb) disable 1
++
++(gdb) si 10
++Se asume que la arquitectura objetivo es i386
++=> 0x7020:	mov    $0x10,%ax
++0x00007020 in ?? ()
++
++(gdb) x/10i $eip
++=> 0x7020:	mov    $0x10,%ax
++   0x7024:	mov    %eax,%ds
++   0x7026:	mov    %eax,%es
++   0x7028:	mov    %eax,%ss
++   0x702a:	mov    $0x0,%ax
++   0x702e:	mov    %eax,%fs
++   0x7030:	mov    %eax,%gs
++   0x7032:	mov    $0x11f000,%eax
++   0x7037:	mov    %eax,%cr3
++   0x703a:	mov    %cr4,%eax
++
++(gdb) watch $eax == 0x11f000
++Watchpoint 2: $eax == 0x11f000
++
++(gdb) c
++Continuando.
++=> 0x7037:	mov    %eax,%cr3
++
++Thread 2 hit Watchpoint 2: $eax == 0x11f000
++
++Old value = 0
++New value = 1
++0x00007037 in ?? ()
++
++(gdb) p $eip
++$2 = (void (*)()) 0x7037
++
++(gdb) p mpentry_kstack
++$3 = (void *) 0x0
++
++(gdb) si 8
++=> 0x704e:	mov    0xf0237f04,%esp
++0x0000704e in ?? ()
++
++(gdb) p mpentry_kstack
++$5 = (void *) 0xf0249000 <percpu_kstacks+65536>
+diff --git a/__pycache__/gradelib.cpython-36.pyc b/__pycache__/gradelib.cpython-36.pyc
+index b0eb354..0fce1e6 100644
+Binary files a/__pycache__/gradelib.cpython-36.pyc and b/__pycache__/gradelib.cpython-36.pyc differ
+diff --git a/grade-lab4 b/grade-lab4
+index 91e52b4..38b4daf 100755
+--- a/grade-lab4
++++ b/grade-lab4
+@@ -40,7 +40,7 @@ def test_yield():
+ 
+ @test(1)
+ def test_spin0():
+-    r.user_test("spin0", timeout=0.5)
++    r.user_test("spin0", timeout=1)
+     r.match(E(".00000000. new env $E1"),
+             E(".00000000. new env $E2"),
+             E("I am $E1 and my spin will go on #1"),
+diff --git a/inc/env.h b/inc/env.h
+index 38ca0f9..defafba 100644
+--- a/inc/env.h
++++ b/inc/env.h
+@@ -33,8 +33,8 @@ typedef int32_t envid_t;
+ enum {
+ 	ENV_FREE = 0,
+ 	ENV_DYING,
+-	ENV_RUNNABLE,
+-	ENV_RUNNING,
++	ENV_RUNNABLE = 20,
++	ENV_RUNNING = 30,
+ 	ENV_NOT_RUNNABLE
+ };
+ 
+diff --git a/kern/entry.S b/kern/entry.S
+index c282a35..32403e3 100644
+--- a/kern/entry.S
++++ b/kern/entry.S
+@@ -57,20 +57,12 @@ entry:
+ 	# Load the physical address of entry_pgdir into cr3.  entry_pgdir
+ 	# is defined in entrypgdir.c.
+ 	movl	$(RELOC(entry_pgdir)), %eax
+-	//orl		$PTE_PS, %eax
+ 	movl	%eax, %cr3
+ 
+ 	movl	%cr4, %eax
+ 	orl		$CR4_PSE, %eax
+ 	movl	%eax, %cr4
+ 
+-	# Realmente se supone que esto es habilitar large pages????
+-	# la concha de tu madre jos
+-	// movl 	%cr4, %eax
+-	// movl	$(RELOC(entry_pgdir)), %eax
+-	// orl		$PTE_PS, %eax
+-	// movl	%eax, %cr4
+-
+ 	# Turn on paging.
+ 	movl	%cr0, %eax
+ 	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax
+diff --git a/kern/env.c b/kern/env.c
+index 25c97b3..158127d 100644
+--- a/kern/env.c
++++ b/kern/env.c
+@@ -416,6 +416,8 @@ env_create(uint8_t *binary, enum EnvType type)
+ 	if (err < 0)
+ 		panic("env_create: %e", err);
+ 
++	// habilito FL_IF para IRQ_TIMER
++	env->env_tf.tf_eflags = FL_IF;
+ 	env->env_type = type;
+ 	load_icode(env, binary);
+ }
+@@ -557,7 +559,8 @@ env_run(struct Env *e)
+ 		e->env_runs++;
+ 		lcr3(PADDR(e->env_pgdir));
+ 	}
+-
++	
++	unlock_kernel();
+ 	env_pop_tf(&e->env_tf);
+ 
+ 	// panic("env_run not yet implemented");
+diff --git a/kern/init.c b/kern/init.c
+index 3c83f7d..b29d033 100644
+--- a/kern/init.c
++++ b/kern/init.c
+@@ -50,6 +50,7 @@ i386_init(void)
+ 
+ 	// Acquire the big kernel lock before waking up APs
+ 	// Your code here:
++	lock_kernel();
+ 
+ 	// Starting non-boot CPUs
+ 	boot_aps();
+@@ -68,14 +69,17 @@ i386_init(void)
+ 		ENV_CREATE(TEST, ENV_TYPE_USER);
+ #else
+ 	// Touch all you want.
+-	ENV_CREATE(user_hello, ENV_TYPE_USER);
+-	ENV_CREATE(user_hello, ENV_TYPE_USER);
+-	ENV_CREATE(user_hello, ENV_TYPE_USER);
++	// 	ENV_CREATE(user_hello, ENV_TYPE_USER);
++	// 	ENV_CREATE(user_yield, ENV_TYPE_USER);
++
++	ENV_CREATE(user_stresssched, ENV_TYPE_USER);
++	//ENV_CREATE(user_hello, ENV_TYPE_USER);
++	//ENV_CREATE(user_hello, ENV_TYPE_USER);
+ #endif // TEST*
+ 
+ 	// Eliminar esta llamada una vez completada la parte 1
+ 	// e implementado sched_yield().
+-	env_run(&envs[0]);
++	//env_run(&envs[0]);
+ 
+ 	// Schedule and run the first user environment!
+ 	sched_yield();
+@@ -131,9 +135,11 @@ mp_main(void)
+ 	// only one CPU can enter the scheduler at a time!
+ 	//
+ 	// Your code here:
++	lock_kernel();
++	sched_yield();
+ 
+ 	// Remove this after you finish Exercise 4
+-	for (;;);
++	// for (;;);
+ }
+ 
+ /*
+diff --git a/kern/mpentry.S b/kern/mpentry.S
+index 72dd827..92a310a 100644
+--- a/kern/mpentry.S
++++ b/kern/mpentry.S
+@@ -64,6 +64,12 @@ start32:
+ 	# we are still running at a low EIP.
+ 	movl    $(RELOC(entry_pgdir)), %eax
+ 	movl    %eax, %cr3
++
++	# Large Pages (extensión PSE)
++	movl	%cr4, %eax
++	orl		$CR4_PSE, %eax
++	movl	%eax, %cr4
++
+ 	# Turn on paging.
+ 	movl    %cr0, %eax
+ 	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+diff --git a/kern/pmap.c b/kern/pmap.c
+index 2befc29..51d228d 100644
+--- a/kern/pmap.c
++++ b/kern/pmap.c
+@@ -299,6 +299,16 @@ mem_init_mp(void)
+ 	//     Permissions: kernel RW, user NONE
+ 	//
+ 	// LAB 4: Your code here:
++	uintptr_t start = KSTACKTOP - KSTKSIZE;
++	for(int i = 0; i < NCPU; i++)
++	{
++		boot_map_region(kern_pgdir,
++	            start - i * (KSTKSIZE + KSTKGAP),
++	            KSTKSIZE,
++	            PADDR(&percpu_kstacks[i]),
++	            PTE_W | PTE_P);
++	}
++
+ }
+ 
+ // --------------------------------------------------------------
+@@ -319,6 +329,10 @@ page_init(void)
+ 	// LAB 4:
+ 	// Change your code to mark the physical page at MPENTRY_PADDR
+ 	// as in use
++	int indice = PGNUM(MPENTRY_PADDR);
++	cprintf("indice MPENTRY_PADDR: %d\n", indice);
++	cprintf("indice npages_basemem: %d\n", npages_basemem);
++
+ 
+ 	// The example code here marks all physical pages as free.
+ 	// However this is not truly the case.  What memory is free?
+@@ -341,6 +355,13 @@ page_init(void)
+ 	for (i = 1; i < npages_basemem;
+ 	     i++) {  // Este for lo que hace es generar la lista enlazada de las
+ 		     // paginas. pages[i].pp_link guarda la direccion de la pagina anterior (pages[i-1])
++		//pages[i].pp_ref = 0;
++
++		if(i == indice) {
++			//pages[i].pp_link = NULL;
++			continue;
++		}	
++
+ 		pages[i].pp_ref = 0;
+ 		pages[i].pp_link = page_free_list;
+ 		page_free_list = &pages[i];
+@@ -356,6 +377,9 @@ page_init(void)
+ 		pages[i].pp_link = page_free_list;
+ 		page_free_list = &pages[i];
+ 	}
++
++	_Static_assert(MPENTRY_PADDR % PGSIZE == 0,
++               "MPENTRY_PADDR is not page-aligned");
+ }
+ 
+ //
+@@ -491,20 +515,6 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
+ 		*pag = physical | perm | PTE_P;
+ 	}
+ #else
+-	/*for(int i = 0; i < size; i+= PGSIZE)
+-	{
+-	        uintptr_t virtual = va + i;
+-	        physaddr_t physical = pa + i;
+-	        if( ((virtual % PTSIZE) == 0) && (size >= PTSIZE) )//&& (size % PTSIZE == 0) )
+-	        {
+-	                pgdir[PDX(virtual)] = physical | perm | PTE_P | PTE_PS;
+-	        }
+-	        else
+-	        {
+-	                pte_t *pag = pgdir_walk(pgdir, (const void*) virtual , 1);
+-	                *pag = physical | perm | PTE_P;
+-	        }
+-	}*/
+ 	while (size >= PGSIZE) {
+ 		if ((va % PTSIZE == 0) && (size >= PTSIZE) &&
+ 		    (pa % PTSIZE == 0))  //&& (size % PTSIZE == 0) )
+@@ -653,7 +663,11 @@ mmio_map_region(physaddr_t pa, size_t size)
+ 	// beginning of the MMIO region.  Because this is static, its
+ 	// value will be preserved between calls to mmio_map_region
+ 	// (just like nextfree in boot_alloc).
+-	static uintptr_t base = MMIOBASE;
++	static uintptr_t base;
++	if(base == 0) {
++		// cprintf("Entre al if");
++		base = MMIOBASE;
++	}
+ 
+ 	// Reserve size bytes of virtual memory starting at base and
+ 	// map physical pages [pa,pa+size) to virtual addresses
+@@ -673,7 +687,20 @@ mmio_map_region(physaddr_t pa, size_t size)
+ 	// Hint: The staff solution uses boot_map_region.
+ 	//
+ 	// Your code here:
+-	panic("mmio_map_region not implemented");
++
++	size_t round_size = ROUNDUP(size, PGSIZE);
++	if ( (base + round_size) > MMIOLIM)
++		panic("mmio_map_region is trying to overflow MMIOLIM");
++
++	boot_map_region(kern_pgdir,
++		base,
++		round_size,
++		pa,
++		PTE_PCD | PTE_PWT | PTE_W | PTE_P);
++
++	void* baseViejo = (void*) base;
++	base = (uintptr_t) (base + round_size);
++	return baseViejo;
+ }
+ 
+ static uintptr_t user_mem_check_addr;
+diff --git a/kern/sched.c b/kern/sched.c
+index 7726e32..80bc9e5 100644
+--- a/kern/sched.c
++++ b/kern/sched.c
+@@ -1,3 +1,4 @@
++
+ #include <inc/assert.h>
+ #include <inc/x86.h>
+ #include <kern/spinlock.h>
+@@ -10,8 +11,9 @@ void sched_halt(void);
+ // Choose a user environment to run and run it.
+ void
+ sched_yield(void)
+-{
++{	
+ 	struct Env *idle;
++	int idx;
+ 
+ 	// Implement simple round-robin scheduling.
+ 	//
+@@ -27,9 +29,45 @@ sched_yield(void)
+ 	// another CPU (env_status == ENV_RUNNING). If there are
+ 	// no runnable environments, simply drop through to the code
+ 	// below to halt the cpu.
+-
+ 	// LAB 4: Your code here.
++	if(!curenv)
++	{
++		idle =  &envs[0];
++		idx = 0;
++	}
++	else{
++		idle = curenv;
++		idx = (curenv - envs) + 1;
++	}
++
++	int iterations = 0;
++	//cprintf("Empiezo la iteracion.\n");
++	while(iterations < (NENV-1) )
++	{	// tengo otro proceso runnable? si es así, lo uso
++		
++		// cprintf("iteracion %d, indice %d\n", iterations, idx);
++		if(envs[idx].env_status == ENV_RUNNABLE)
++		{
++			if(curenv != NULL) {
++				//cprintf("Set al curenv environment en Runnable. Esto implica que voy a correr otro\n");
++				curenv->env_status = ENV_RUNNABLE;
++			}
++			//cprintf("Env run, iteracion %d\n", iterations);
++			env_run(&envs[idx]);
++		}
++
++		iterations++;
++		idx++;
++		if(idx == NENV) {
++			//cprintf("reseteo el idx.\n");
++			idx = 0;
++		}
++	}
++	 // sino le vuelvo a dar el time slice al que estaba corriendo
++	if(idle->env_status == ENV_RUNNING)
++		env_run(idle);
+ 
++	// else, si no esta running y no tengo ninguno runnable, entonces voy a sched_halt
+ 	// sched_halt never returns
+ 	sched_halt();
+ }
+diff --git a/kern/syscall.c b/kern/syscall.c
+index e98ae08..194473d 100644
+--- a/kern/syscall.c
++++ b/kern/syscall.c
+@@ -68,6 +68,8 @@ sys_env_destroy(envid_t envid)
+ static void
+ sys_yield(void)
+ {
++	// Cambiamos esto...
++	// curenv->env_status = ENV_RUNNABLE;
+ 	sched_yield();
+ }
+ 
+@@ -85,7 +87,19 @@ sys_exofork(void)
+ 	// will appear to return 0.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_exofork not implemented");
++	
++	struct Env *e;
++	int resultado = env_alloc(&e, thiscpu->cpu_env->env_id);
++	if(resultado < 0)	// ambos errores contemplados en env_alloc
++		return resultado;
++
++	//e->env_tf.tf_regs = thiscpu->cpu_env->env_tf.tf_regs;
++	e->env_tf = thiscpu->cpu_env->env_tf;
++	e->env_tf.tf_regs.reg_eax = 0;
++	e->env_status = ENV_NOT_RUNNABLE;
++
++	// int prueba = e->env_id;
++	return (e->env_id);
+ }
+ 
+ // Set envid's env_status to status, which must be ENV_RUNNABLE
+@@ -105,7 +119,18 @@ sys_env_set_status(envid_t envid, int status)
+ 	// envid's status.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_env_set_status not implemented");
++
++	if( (status != ENV_RUNNABLE) && (status != ENV_NOT_RUNNABLE) )
++		return -E_INVAL;
++
++	struct Env *e;
++	int resultado = envid2env(envid, &e, 1);
++	if (resultado < 0)
++		return resultado;	// esto es -E_BAD_ENV
++
++	// si llegamos hasta acá salió todo bien. Cambio el status
++	e->env_status = status;
++	return 0;
+ }
+ 
+ // Set the page fault upcall for 'envid' by modifying the corresponding struct
+@@ -150,7 +175,29 @@ sys_page_alloc(envid_t envid, void *va, int perm)
+ 	//   allocated!
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_alloc not implemented");
++	//panic("sys_page_alloc not implemented");
++
++	if( ((uint32_t)va >= UTOP) || ((uint32_t)va % PGSIZE != 0) )
++		return -E_INVAL;
++	if( (perm & (PTE_U|PTE_P)) != (PTE_U|PTE_P) )
++		return -E_INVAL;
++
++	struct Env* e;
++	int resultado = envid2env(envid, &e, 1);
++	if (resultado < 0)
++		return resultado;
++
++	struct PageInfo *page = page_alloc(ALLOC_ZERO);
++	if(!page)
++		return -E_NO_MEM;
++
++	resultado = page_insert(e->env_pgdir, page, va, perm);
++	if(resultado < 0) {
++		page_free(page);
++		return -E_NO_MEM;
++	}
++
++	return 0;
+ }
+ 
+ // Map the page of memory at 'srcva' in srcenvid's address space
+@@ -180,7 +227,37 @@ sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int p
+ 	//   check the current permissions on the page.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_map not implemented");
++	if( ((uint32_t)srcva >= UTOP) || ((uint32_t)srcva % PGSIZE != 0) )
++		return -E_INVAL;
++	if( ((uint32_t)dstva >= UTOP) || ((uint32_t)dstva % PGSIZE != 0) )
++		return -E_INVAL;
++	// mismo chequeo de permisos que en sys_page_alloc
++	if( (perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P) )
++		return -E_INVAL;
++
++	struct Env *srcenv;
++	struct Env *dstenv;
++	int res1 = envid2env(srcenvid, &srcenv, 1);
++	int res2 = envid2env(dstenvid, &dstenv, 1);
++	if( (res1 < 0) || (res2 < 0) )
++		return -E_BAD_ENV;
++
++	pte_t* pte;
++
++	struct PageInfo* page = page_lookup(srcenv->env_pgdir, srcva, &pte);
++	if(!page)
++		-E_INVAL;
++	
++	//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
++	//		address space.
++	if( ((*pte & PTE_W) == 0) && ((perm & PTE_W) == PTE_W) )
++		return -E_INVAL;
++
++	res1 = page_insert(dstenv->env_pgdir, page, dstva, perm);
++	if(res1 < 0)
++		return -E_NO_MEM;
++
++	return 0;
+ }
+ 
+ // Unmap the page of memory at 'va' in the address space of 'envid'.
+@@ -196,7 +273,15 @@ sys_page_unmap(envid_t envid, void *va)
+ 	// Hint: This function is a wrapper around page_remove().
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_unmap not implemented");
++	if( (uint32_t)va >= UTOP )
++		return -E_INVAL;
++	struct Env *e;
++	int res = envid2env(envid, &e, 1);
++	if (res < 0)
++		return -E_BAD_ENV;
++
++	page_remove(e->env_pgdir, va);
++	return 0;
+ }
+ 
+ // Try to send 'value' to the target env 'envid'.
+@@ -270,7 +355,7 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
+ 	// Call the function corresponding to the 'syscallno' parameter.
+ 	// Return any appropriate return value.
+ 	// LAB 3: Your code here.
+-	int ret = 0;
++	int ret = 0;	// código de error arbitrario?
+ 	switch (syscallno) {
+ 	case SYS_cputs:
+ 		sys_cputs((char *) a1, a2);
+@@ -286,6 +371,26 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
+ 		sys_env_destroy(a1);
+ 		ret = 0;
+ 		break;
++	case SYS_exofork:
++		ret = sys_exofork();
++		break;
++	case SYS_page_alloc:
++		ret = sys_page_alloc((envid_t) a1, (void*) a2, (int32_t) a3);
++		break;
++	case SYS_env_set_status:
++		ret = sys_env_set_status( (envid_t) a1, (int32_t) a2);
++		int prueba = ret;
++		break;
++	case SYS_page_map:
++		ret = sys_page_map((envid_t) a1, (void*) a2, (envid_t) a3, (void*) a4, (int32_t)a5);
++		break;
++	case SYS_page_unmap:
++		ret = sys_page_unmap( (envid_t) a1, (void*) a2);
++		break;
++	case SYS_yield:
++		sys_yield();
++		break;
++
+ 	default:
+ 		ret = -E_INVAL;
+ 	}
+diff --git a/kern/trap.c b/kern/trap.c
+index 6c47a98..f16ddb4 100644
+--- a/kern/trap.c
++++ b/kern/trap.c
+@@ -14,7 +14,7 @@
+ #include <kern/cpu.h>
+ #include <kern/spinlock.h>
+ 
+-static struct Taskstate ts;
++// tatic struct Taskstate ts;
+ 
+ /* For debugging, so print_trapframe can distinguish between printing
+  * a saved trapframe and printing the current trapframe and print some
+@@ -92,6 +92,7 @@ trap_init(void)
+ 	void trap_handler_18();
+ 	void trap_handler_19();
+ 	void trap_handler_20();
++	void trap_handler_32();
+ 	void trap_handler_48();
+ 
+ 	SETGATE(idt[0], 0, GD_KT, trap_handler_0, 0);
+@@ -119,6 +120,10 @@ trap_init(void)
+ 	SETGATE(idt[18], 0, GD_KT, trap_handler_18, 0);
+ 	SETGATE(idt[19], 0, GD_KT, trap_handler_19, 0);
+ 	SETGATE(idt[20], 0, GD_KT, trap_handler_20, 0);
++
++	//IRQ_TIMER
++	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], 0, GD_KT, trap_handler_32, 0);
++
+ 	SETGATE(idt[48], 0, GD_KT, trap_handler_48, 3);
+ 
+ 
+@@ -155,18 +160,27 @@ trap_init_percpu(void)
+ 
+ 	// Setup a TSS so that we get the right stack
+ 	// when we trap to the kernel.
+-	ts.ts_esp0 = KSTACKTOP;
+-	ts.ts_ss0 = GD_KD;
+-	ts.ts_iomb = sizeof(struct Taskstate);
++
++	int id = cpunum();
++	struct CpuInfo *cpu = &cpus[id];
++	struct Taskstate *ts = &cpu->cpu_ts;
++
++	uintptr_t ts_stack = (KSTACKTOP) - id * (KSTKSIZE + KSTKGAP);
++
++	ts->ts_esp0 = ts_stack;
++	ts->ts_ss0 = GD_KD;
++	ts->ts_iomb = sizeof(struct Taskstate);
+ 
+ 	// Initialize the TSS slot of the gdt.
+-	gdt[GD_TSS0 >> 3] =
+-	        SEG16(STS_T32A, (uint32_t)(&ts), sizeof(struct Taskstate) - 1, 0);
+-	gdt[GD_TSS0 >> 3].sd_s = 0;
++	uint16_t idx = (GD_TSS0 >> 3) + id;
++	gdt[idx] =
++	        SEG16(STS_T32A, (uint32_t)(ts), sizeof(struct Taskstate) - 1, 0);
++	gdt[idx].sd_s = 0;
+ 
+ 	// Load the TSS selector (like other segment selectors, the
+ 	// bottom three bits are special; we leave them 0)
+-	ltr(GD_TSS0);
++	uint16_t seg = idx << 3;
++	ltr(seg);
+ 
+ 	// Load the IDT
+ 	lidt(&idt_pd);
+@@ -255,6 +269,11 @@ trap_dispatch(struct Trapframe *tf)
+ 	// Handle clock interrupts. Don't forget to acknowledge the
+ 	// interrupt using lapic_eoi() before calling the scheduler!
+ 	// LAB 4: Your code here.
++	if ( (tf->tf_eflags & FL_IF) == FL_IF) {
++		// cprintf("Estoy en FL_IF");
++		lapic_eoi();
++		sched_yield();
++	}
+ 
+ 	// Unexpected trap: The user process or the kernel has a bug.
+ 	print_trapframe(tf);
+@@ -292,6 +311,7 @@ trap(struct Trapframe *tf)
+ 		// Acquire the big kernel lock before doing any
+ 		// serious kernel work.
+ 		// LAB 4: Your code here.
++		lock_kernel();
+ 		assert(curenv);
+ 
+ 		// Garbage collect if current enviroment is a zombie
+diff --git a/kern/trapentry.S b/kern/trapentry.S
+index bf2223b..38beb58 100644
+--- a/kern/trapentry.S
++++ b/kern/trapentry.S
+@@ -72,6 +72,8 @@ TRAPHANDLER_NOEC(trap_handler_18, 18);
+ TRAPHANDLER_NOEC(trap_handler_19, 19);
+ TRAPHANDLER_NOEC(trap_handler_20, 20);
+ 
++//IRQ TIMER
++TRAPHANDLER_NOEC(trap_handler_32, 32);
+ TRAPHANDLER_NOEC(trap_handler_48, 48);
+ /*
+  * Lab 3: Your code here for _alltraps
+diff --git a/lib/fork.c b/lib/fork.c
+index d32749e..6ee2194 100644
+--- a/lib/fork.c
++++ b/lib/fork.c
+@@ -58,6 +58,60 @@ duppage(envid_t envid, unsigned pn)
+ 	return 0;
+ }
+ 
++static void
++dup_or_share(envid_t dstenv, void *va, int perm)
++{
++	int r;
++
++	if( perm & PTE_W )
++	{
++		if ((r = sys_page_alloc(dstenv, va, perm)) < 0)
++		panic("sys_page_alloc: %e", r);
++	}
++	if ((r = sys_page_map(dstenv, va, 0, UTEMP, perm)) < 0)
++		panic("sys_page_map: %e", r);
++	memmove(UTEMP, va, PGSIZE);
++	if ((r = sys_page_unmap(0, UTEMP)) < 0)
++		panic("sys_page_unmap: %e", r);
++	
++}
++
++
++envid_t fork_v0(void)
++{
++	envid_t envid;
++
++	envid = sys_exofork();
++	if(envid < 0)
++	{
++		panic("sys_exofork: %e", envid);
++	}
++	if(envid == 0) //Hijo
++	{
++
++		//if(sys_env_set_status(thisenv->env_id, ENV_RUNNABLE) < 0)
++		//	panic("sys_env_set_status en fork_v0\n");
++		thisenv = &envs[ENVX(sys_getenvid())];
++		return 0;
++	}
++
++	//Padre
++
++	uint32_t va;
++	for(va = 0; va < UTOP; va += PGSIZE)
++	{
++		if( (uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_U) )
++			dup_or_share(envid, (void*) va, uvpt[PGNUM(va)] & PTE_SYSCALL);
++	}
++
++	// Start the child environment running
++	if( sys_env_set_status(envid, ENV_RUNNABLE) < 0) 
++		panic("sys_env_set_status");
++	// cprintf("Seteamos el status del hijo\n");
++	
++	return envid;
++}
++
+ //
+ // User-level fork with copy-on-write.
+ // Set up our page fault handler appropriately.
+@@ -77,10 +131,11 @@ duppage(envid_t envid, unsigned pn)
+ envid_t
+ fork(void)
+ {
+-	// LAB 4: Your code here.
+-	panic("fork not implemented");
++	return fork_v0();
++	// panic("fork not implemented");
+ }
+ 
++
+ // Challenge!
+ int
+ sfork(void)
+diff --git a/user/dumbfork.c b/user/dumbfork.c
+index e5e433c..6442da2 100644
+--- a/user/dumbfork.c
++++ b/user/dumbfork.c
+@@ -18,6 +18,8 @@ umain(int argc, char **argv)
+ 	// print a message and yield to the other a few times
+ 	for (i = 0; i < (who ? 10 : 20); i++) {
+ 		cprintf("%d: I am the %s!\n", i, who ? "parent" : "child");
++		int32_t id = (int32_t) sys_getenvid();
++		cprintf("El envid es %d\n", id);
+ 		sys_yield();
+ 	}
+ }
+diff --git a/user/yield.c b/user/yield.c
+index 6f45bdb..ed7ea16 100644
+--- a/user/yield.c
++++ b/user/yield.c
+@@ -7,11 +7,11 @@ umain(int argc, char **argv)
+ {
+ 	int i;
+ 
+-	cprintf("Hello, I am environment %08x.\n", thisenv->env_id);
++	cprintf("Hello, I am environment %08x, cpu %d\n", thisenv->env_id, thisenv->env_cpunum);
+ 	for (i = 0; i < 5; i++) {
+ 		sys_yield();
+-		cprintf("Back in environment %08x, iteration %d.\n",
+-			thisenv->env_id, i);
++		cprintf("Back in environment %08x, iteration %d, cpu %d\n",
++			thisenv->env_id, i, thisenv->env_cpunum);
+ 	}
+ 	cprintf("All done in environment %08x.\n", thisenv->env_id);
+ }
diff --git a/entregaIncompleta_tp3.txt b/entregaIncompleta_tp3.txt
new file mode 100644
index 0000000..70478d6
--- /dev/null
+++ b/entregaIncompleta_tp3.txt
@@ -0,0 +1,1019 @@
+diff --git a/TP3.md b/TP3.md
+new file mode 100644
+index 0000000..fbd1311
+--- /dev/null
++++ b/TP3.md
+@@ -0,0 +1,303 @@
++TP3.md
++======
++
++
++static_assert:
++-------------
++
++
++
++env_return:
++----------
++
++// HAY UNA RESPUESTA EN EL GRUPO que se llama Duda env_return QUE RESPONDE ESTO
++
++Env_run() es la función encargada de llamar a env_pop_tf() que le cede el control al usuario. Cuando un proceso de usuario terminó de ejecutarse, entonces se llama a la función trap() por medio de ¿¿¿¿¿¿¿la int 0x30?????, ésta función llama a trap_dispatch() que a su vez ejecuta la syscall correspondiente. En éste caso, como el proceso ya terminó de ejecutarse el parámetro syscallno almacenará el valor de la constante SYS_env_destroy. 
++Luego de la syscall, cuando trap_dispatch() finalice y la ejecución llegue a trap(), el kernel verifica que el proceso que se está corriendo ya no está en estado de ENV_RUNNING, por lo que llama a la función sched_yield(), la cual aún no está implementada y al final llama a sched_halt que interrumpe la CPU porque no hay nada para hacer hasta que el timer la despierte.
++
++En el trabajo práctico anterior (TP2), env_destroy() ejecutaba a env_free() y automáticamente llamaba al monitor() de Jos. En este nuevo TP, sched_yield() se encargará de seguir ejecutando otros procesos cuando el actual sea liberado.
++
++sys_yield:
++---------
++
++nicolas@nicolas-PC:~/sisop$ make qemu-nox
+++ cc kern/init.c
+++ ld obj/kern/kernel
+++ mk obj/kern/kernel.img
++***
++*** Use Ctrl-a x to exit qemu
++***
++qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp:127.0.0.1:26000 -D qemu.log -smp 1  -d guest_errors
++6828 decimal is 15254 octal!
++Physical memory: 131072K available, base = 640K, extended = 130432K
++boot_alloc memory at f0278000
++Next memory at f0279000
++boot_alloc memory at f0279000
++Next memory at f02b9000
++npages: 32768
++npages_basemem: 160
++pages: f0279000
++boot_alloc memory at f02b9000
++Next memory at f02d8000
++indice MPENTRY_PADDR: 7
++indice npages_basemem: 160
++boot_alloc memory at f02d8000
++Next memory at f02d8000
++pageinfo size: 8
++f02b9000
++med=728
++boot_alloc memory at f02d8000
++Next memory at f02d8000
++check_page_free_list() succeeded!
++check_page_alloc() succeeded!
++check_page() succeeded!
++check_kern_pgdir() succeeded!
++boot_alloc memory at f02d8000
++Next memory at f02d8000
++check_page_free_list() succeeded!
++check_page_installed_pgdir() succeeded!
++SMP: CPU 0 found 1 CPU(s)
++enabled interrupts: 1 2
++[00000000] new env 00001000
++[00000000] new env 00001001
++[00000000] new env 00001002
++Hello, I am environment 00001000.
++Hello, I am environment 00001001.
++Hello, I am environment 00001002.
++Back in environment 00001000, iteration 0.
++Back in environment 00001001, iteration 0.
++Back in environment 00001002, iteration 0.
++Back in environment 00001000, iteration 1.
++Back in environment 00001001, iteration 1.
++Back in environment 00001002, iteration 1.
++Back in environment 00001001, iteration 2.
++Back in environment 00001002, iteration 2.
++Back in environment 00001000, iteration 2.
++Back in environment 00001001, iteration 3.
++Back in environment 00001002, iteration 3.
++Back in environment 00001000, iteration 3.
++Back in environment 00001001, iteration 4.
++All done in environment 00001001.
++[00001001] exiting gracefully
++[00001001] free env 00001001
++Back in environment 00001000, iteration 4.
++All done in environment 00001000.
++[00001000] exiting gracefully
++[00001000] free env 00001000
++Back in environment 00001002, iteration 4.
++All done in environment 00001002.
++[00001002] exiting gracefully
++[00001002] free env 00001002
++No runnable environments in the system!
++Welcome to the JOS kernel monitor!
++Type 'help' for a list of commands.
++K> 
++
++El código del archivo user/yield.c recorre un ciclo y llama a la función sys_yield() un total de 4 veces, devolviéndole el control al Kernel.
++Al modificar i386_init() para crear tres ambientes que corran este programa, la salida obtenida es la esperada: los 3 ambientes se crean, se ejecutan en orden y van llamando por primera vez a sys_yield: primero lo hace el primer ambiente (env_id = 00001000), luego el segundo (env_id = 00001001) y por último el tercero (env_id = 00001002), todos ellos dejando el control casi inmediatamente.
++Entonces el scheduler va a ir devolviéndole el control a cada uno en el mismo orden. Primero, volverá el primer ambiente a finalizar la primera iteración del ciclo, entrará en la segunda y devolverá la ejecución al kernel; éste se la entregará al segundo ambiente que finalizará la primera iteración, entrará en la segunda y devolverá la ejecución al kernel; etc.
++Ésta salida evidencia que el Scheduler implementa el algoritmo de scheduling conocido como Round-Robin.
++
++
++envid2env:
++---------
++
++En Jos, si un proceso llama sys_env_destroy(0), entonces éste buscará el environment correspondiente al id que recibió por parámetro (en este caso, el environment 0). Al comenzar la ejecución de sys_env_destroy() hay una comparación: si el parámetro recibido es 0, entonces se devolverá el environment actual (*curenv*).
++En Linux, si un proceso llama a kill(0,9), el primer argumento (pid_t pid) al ser 0 especifica que se envía el mensaje signal (en este caso 9) a todos los procesos del "process group" del proceso que llamó al wrapper de la syscall.
++
++De igual manera, en Jos, sys_get_env_destroy(-1) devolverá el error -E_BAD_ENV ya que un ambiente en Jos no puede tener id negativo
++En Linux, la llamada kill(-1, 9) le envía la señal 9 a todos aquellos procesos a los que el proceso que invoco al wrapper TIENE PERMISO para enviarle la señal (a excepción del proceso 1, es decir init).
++
++
++dumbfork:
++--------
++
++1. Si la página se reserva entre UTOP y char* end (lo que sucederá), entonces al llamar a dumbfork() se propagará la copia al proceso hijo.
++2. 
++// No sé bien si se preserva el estado de sólo lectura. sys_page_map() chequea esto para no copiar con permisos de escritura una página de sólo lectura. Pero en este caso debiera devolver un número negativo y resultaría en un panic, y no está pasando...
++//
++
++El estado de solo lectura no se preserva. La función duppage setea los bits de presencia, usuario y escritura. Esto es necesario, para poder realizar la copia de una página a la otra.
++	void* algunPuntero;
++	pde_t pageDir = uvpd[PDX(algunPuntero)];
++	pte_t pageTable = uvpt[PTX(algunPuntero)];
++	if(*pageTable & PTE_W)
++		return true;
++	else
++		return false;*
++
++
++3. La función duppage() literalmente duplica una página que es del padre, y la copia en el proceso hijo. En primer lugar reserva una página nueva (utilizando la misma dirección virtual que le corresponde en el espacio de direcciones del padre), luego la mappea en la dirección UTEMP de su propio espacio de direcciones.
++Por último, una vez ahí copia el contenido de la página en UTEMP de manera tal que queda copiado en el espacio de direcciones del proceso hijo. Por último, *desmappea* la página de UTEMP.
++
++4.  Si el booleano fuera true, entonces debería hacerse una llamada adicional de 
++
++	Si quisiéramos poder definir a la página como solo-lectura sin aumentar el número de llamadas al sistema podríamos acceder al valor almacenado en la pte_t* para la dirección en cuestión y ahí setear "a mano" el bit de escritura (PTE_W) en cero.
++
++5. 
++
++
++
++multicore_init:
++--------------
++
++1. La línea de código mencionada carga en memoria baja (una dirección virtual V en la que está mappeada la dirección física MPENTRY_ADDR, es decir 0x7000) parte del código escrito en el archivo mpentry.S. Analogamente a lo que sucede con el bootloader en boot.S , las application processor (o AP) bootean en real mode pero con la ventaja de que podemos realizar un mapeo que nos simplifique la ejecución del código.
++
++2. ¿Para qué se usa la variable global mpentry_kstack? ¿Qué ocurriría si el espacio para este stack se reservara en el archivo kern/mpentry.S, de manera similar a bootstack en el archivo kern/entry.S?
++
++La variable global mpentry_kstack apunta al tope de la dirección del Kernel Stack de cada uno de los CPUs.
++En kern/entry.S, código que es ejecutado por una CPU, se setea el stack pointer al final del código mismo. Esto solo podría realizarse desde mpentry.S si todos los CPUs compartieran el mismo stack, y esto no funcionaría ya que al recibir interrupciones en simultáneo se pisaría la información de cada uno de los CPUs.
++
++3. 
++nicolas@nicolas-PC:~/sisop$ make gdḅ 
++~
++(gdb) watch mpentry_kstack
++Hardware watchpoint 1: mpentry_kstack
++(gdb) c
++Continuando.
++Se asume que la arquitectura objetivo es i386
++=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
++
++Thread 1 hit Hardware watchpoint 1: mpentry_kstack
++
++Old value = (void *) 0x0
++New value = (void *) 0xf0249000 <percpu_kstacks+65536>*
++boot_aps () at kern/init.c:112
++112			lapic_startap(c->cpu_id, PADDR(code));
++
++(gdb) bt
++#0  boot_aps () at kern/init.c:112
++#1  0xf010020f in i386_init () at kern/init.c:55
++#2  0xf0100047 in relocated () at kern/entry.S:88
++
++(gdb) info threads
++  Id   Target Id         Frame 
++* 1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
++  2    Thread 2 (CPU#1 [halted ]) 0x000fd412 in ?? ()
++  3    Thread 3 (CPU#2 [halted ]) 0x000fd412 in ?? ()
++  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
++
++(gdb) c
++Continuando.
++=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
++
++Thread 1 hit Hardware watchpoint 1: mpentry_kstack
++
++Old value = (void *) 0xf0249000 <percpu_kstacks+65536>
++New value = (void *) 0xf0251000 <percpu_kstacks+98304>
++boot_aps () at kern/init.c:112
++112			lapic_startap(c->cpu_id, PADDR(code));
++
++(gdb) info threads
++  Id   Target Id         Frame 
++  1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
++  2    Thread 2 (CPU#1 [running]) 0xf010027f in mp_main () at kern/init.c:130
++  3    Thread 3 (CPU#2 [halted ]) 0x000fd412 in ?? ()
++  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
++
++(gdb) thread 2
++[Switching to thread 2 (Thread 2)]
++#0  0xf010027f in mp_main () at kern/init.c:130
++130		xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
++
++(gdb) bt
++#0  0xf010027f in mp_main () at kern/init.c:130
++#1  0x00007060 in ?? ()
++
++(gdb) p cpunum()
++
++-------------------------- FALTA
++
++(gdb) thread 1
++[Switching to thread 1 (Thread 1)]
++#0  boot_aps () at kern/init.c:112
++112			lapic_startap(c->cpu_id, PADDR(code));
++
++(gdb) p cpunum()
++
++-------------------------- FALTA
++
++(gdb) c
++Continuando.
++=> 0xf0100186 <boot_aps+127>:	mov    %esi,%ecx
++
++Thread 1 hit Hardware watchpoint 1: mpentry_kstack
++
++Old value = (void *) 0xf0251000 <percpu_kstacks+98304>
++New value = (void *) 0xf0259000 <percpu_kstacks+131072>
++boot_aps () at kern/init.c:112
++112			lapic_startap(c->cpu_id, PADDR(code));
++
++(gdb) info threads
++  Id   Target Id         Frame 
++* 1    Thread 1 (CPU#0 [running]) boot_aps () at kern/init.c:112
++  2    Thread 2 (CPU#1 [running]) 0xf010027f in mp_main () at kern/init.c:130
++  3    Thread 3 (CPU#2 [running]) 0xf010027f in mp_main () at kern/init.c:130
++  4    Thread 4 (CPU#3 [halted ]) 0x000fd412 in ?? ()
++(gdb) 
++
++
++4. mpentry.S se ejecuta en cada una de las CPUs. Se empieza a ejecutar en la dirección virtual mapeada con 0x7000 en dir física.
++
++La ejecución no se detiene al poner un breakpoint en mpentry_start porque jajajajajajsss
++
++5. nicolas@nicolas-PC:~/sisop$ make gdb ~
++
++(gdb) b *0x7000 thread 4
++Punto de interrupción 1 at 0x7000
++(gdb) c
++Continuando.
++
++Thread 2 received signal SIGTRAP, Trace/breakpoint trap.
++[Cambiando a Thread 2]
++Se asume que la arquitectura objetivo es i8086
++[ 700:   0]    0x7000:	cli    
++0x00000000 in ?? ()
++
++(gdb) p $eip
++$1 = (void (*)()) 0x0
++
++(gdb) disable 1
++
++(gdb) si 10
++Se asume que la arquitectura objetivo es i386
++=> 0x7020:	mov    $0x10,%ax
++0x00007020 in ?? ()
++
++(gdb) x/10i $eip
++=> 0x7020:	mov    $0x10,%ax
++   0x7024:	mov    %eax,%ds
++   0x7026:	mov    %eax,%es
++   0x7028:	mov    %eax,%ss
++   0x702a:	mov    $0x0,%ax
++   0x702e:	mov    %eax,%fs
++   0x7030:	mov    %eax,%gs
++   0x7032:	mov    $0x11f000,%eax
++   0x7037:	mov    %eax,%cr3
++   0x703a:	mov    %cr4,%eax
++
++(gdb) watch $eax == 0x11f000
++Watchpoint 2: $eax == 0x11f000
++
++(gdb) c
++Continuando.
++=> 0x7037:	mov    %eax,%cr3
++
++Thread 2 hit Watchpoint 2: $eax == 0x11f000
++
++Old value = 0
++New value = 1
++0x00007037 in ?? ()
++
++(gdb) p $eip
++$2 = (void (*)()) 0x7037
++
++(gdb) p mpentry_kstack
++$3 = (void *) 0x0
++
++(gdb) si 8
++=> 0x704e:	mov    0xf0237f04,%esp
++0x0000704e in ?? ()
++
++(gdb) p mpentry_kstack
++$5 = (void *) 0xf0249000 <percpu_kstacks+65536>
+diff --git a/__pycache__/gradelib.cpython-36.pyc b/__pycache__/gradelib.cpython-36.pyc
+index b0eb354..0fce1e6 100644
+Binary files a/__pycache__/gradelib.cpython-36.pyc and b/__pycache__/gradelib.cpython-36.pyc differ
+diff --git a/grade-lab4 b/grade-lab4
+index 91e52b4..38b4daf 100755
+--- a/grade-lab4
++++ b/grade-lab4
+@@ -40,7 +40,7 @@ def test_yield():
+ 
+ @test(1)
+ def test_spin0():
+-    r.user_test("spin0", timeout=0.5)
++    r.user_test("spin0", timeout=1)
+     r.match(E(".00000000. new env $E1"),
+             E(".00000000. new env $E2"),
+             E("I am $E1 and my spin will go on #1"),
+diff --git a/inc/env.h b/inc/env.h
+index 38ca0f9..defafba 100644
+--- a/inc/env.h
++++ b/inc/env.h
+@@ -33,8 +33,8 @@ typedef int32_t envid_t;
+ enum {
+ 	ENV_FREE = 0,
+ 	ENV_DYING,
+-	ENV_RUNNABLE,
+-	ENV_RUNNING,
++	ENV_RUNNABLE = 20,
++	ENV_RUNNING = 30,
+ 	ENV_NOT_RUNNABLE
+ };
+ 
+diff --git a/kern/entry.S b/kern/entry.S
+index c282a35..32403e3 100644
+--- a/kern/entry.S
++++ b/kern/entry.S
+@@ -57,20 +57,12 @@ entry:
+ 	# Load the physical address of entry_pgdir into cr3.  entry_pgdir
+ 	# is defined in entrypgdir.c.
+ 	movl	$(RELOC(entry_pgdir)), %eax
+-	//orl		$PTE_PS, %eax
+ 	movl	%eax, %cr3
+ 
+ 	movl	%cr4, %eax
+ 	orl		$CR4_PSE, %eax
+ 	movl	%eax, %cr4
+ 
+-	# Realmente se supone que esto es habilitar large pages????
+-	# la concha de tu madre jos
+-	// movl 	%cr4, %eax
+-	// movl	$(RELOC(entry_pgdir)), %eax
+-	// orl		$PTE_PS, %eax
+-	// movl	%eax, %cr4
+-
+ 	# Turn on paging.
+ 	movl	%cr0, %eax
+ 	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax
+diff --git a/kern/env.c b/kern/env.c
+index 25c97b3..158127d 100644
+--- a/kern/env.c
++++ b/kern/env.c
+@@ -416,6 +416,8 @@ env_create(uint8_t *binary, enum EnvType type)
+ 	if (err < 0)
+ 		panic("env_create: %e", err);
+ 
++	// habilito FL_IF para IRQ_TIMER
++	env->env_tf.tf_eflags = FL_IF;
+ 	env->env_type = type;
+ 	load_icode(env, binary);
+ }
+@@ -557,7 +559,8 @@ env_run(struct Env *e)
+ 		e->env_runs++;
+ 		lcr3(PADDR(e->env_pgdir));
+ 	}
+-
++	
++	unlock_kernel();
+ 	env_pop_tf(&e->env_tf);
+ 
+ 	// panic("env_run not yet implemented");
+diff --git a/kern/init.c b/kern/init.c
+index 3c83f7d..b29d033 100644
+--- a/kern/init.c
++++ b/kern/init.c
+@@ -50,6 +50,7 @@ i386_init(void)
+ 
+ 	// Acquire the big kernel lock before waking up APs
+ 	// Your code here:
++	lock_kernel();
+ 
+ 	// Starting non-boot CPUs
+ 	boot_aps();
+@@ -68,14 +69,17 @@ i386_init(void)
+ 		ENV_CREATE(TEST, ENV_TYPE_USER);
+ #else
+ 	// Touch all you want.
+-	ENV_CREATE(user_hello, ENV_TYPE_USER);
+-	ENV_CREATE(user_hello, ENV_TYPE_USER);
+-	ENV_CREATE(user_hello, ENV_TYPE_USER);
++	// 	ENV_CREATE(user_hello, ENV_TYPE_USER);
++	// 	ENV_CREATE(user_yield, ENV_TYPE_USER);
++
++	ENV_CREATE(user_stresssched, ENV_TYPE_USER);
++	//ENV_CREATE(user_hello, ENV_TYPE_USER);
++	//ENV_CREATE(user_hello, ENV_TYPE_USER);
+ #endif // TEST*
+ 
+ 	// Eliminar esta llamada una vez completada la parte 1
+ 	// e implementado sched_yield().
+-	env_run(&envs[0]);
++	//env_run(&envs[0]);
+ 
+ 	// Schedule and run the first user environment!
+ 	sched_yield();
+@@ -131,9 +135,11 @@ mp_main(void)
+ 	// only one CPU can enter the scheduler at a time!
+ 	//
+ 	// Your code here:
++	lock_kernel();
++	sched_yield();
+ 
+ 	// Remove this after you finish Exercise 4
+-	for (;;);
++	// for (;;);
+ }
+ 
+ /*
+diff --git a/kern/mpentry.S b/kern/mpentry.S
+index 72dd827..92a310a 100644
+--- a/kern/mpentry.S
++++ b/kern/mpentry.S
+@@ -64,6 +64,12 @@ start32:
+ 	# we are still running at a low EIP.
+ 	movl    $(RELOC(entry_pgdir)), %eax
+ 	movl    %eax, %cr3
++
++	# Large Pages (extensión PSE)
++	movl	%cr4, %eax
++	orl		$CR4_PSE, %eax
++	movl	%eax, %cr4
++
+ 	# Turn on paging.
+ 	movl    %cr0, %eax
+ 	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+diff --git a/kern/pmap.c b/kern/pmap.c
+index 2befc29..51d228d 100644
+--- a/kern/pmap.c
++++ b/kern/pmap.c
+@@ -299,6 +299,16 @@ mem_init_mp(void)
+ 	//     Permissions: kernel RW, user NONE
+ 	//
+ 	// LAB 4: Your code here:
++	uintptr_t start = KSTACKTOP - KSTKSIZE;
++	for(int i = 0; i < NCPU; i++)
++	{
++		boot_map_region(kern_pgdir,
++	            start - i * (KSTKSIZE + KSTKGAP),
++	            KSTKSIZE,
++	            PADDR(&percpu_kstacks[i]),
++	            PTE_W | PTE_P);
++	}
++
+ }
+ 
+ // --------------------------------------------------------------
+@@ -319,6 +329,10 @@ page_init(void)
+ 	// LAB 4:
+ 	// Change your code to mark the physical page at MPENTRY_PADDR
+ 	// as in use
++	int indice = PGNUM(MPENTRY_PADDR);
++	cprintf("indice MPENTRY_PADDR: %d\n", indice);
++	cprintf("indice npages_basemem: %d\n", npages_basemem);
++
+ 
+ 	// The example code here marks all physical pages as free.
+ 	// However this is not truly the case.  What memory is free?
+@@ -341,6 +355,13 @@ page_init(void)
+ 	for (i = 1; i < npages_basemem;
+ 	     i++) {  // Este for lo que hace es generar la lista enlazada de las
+ 		     // paginas. pages[i].pp_link guarda la direccion de la pagina anterior (pages[i-1])
++		//pages[i].pp_ref = 0;
++
++		if(i == indice) {
++			//pages[i].pp_link = NULL;
++			continue;
++		}	
++
+ 		pages[i].pp_ref = 0;
+ 		pages[i].pp_link = page_free_list;
+ 		page_free_list = &pages[i];
+@@ -356,6 +377,9 @@ page_init(void)
+ 		pages[i].pp_link = page_free_list;
+ 		page_free_list = &pages[i];
+ 	}
++
++	_Static_assert(MPENTRY_PADDR % PGSIZE == 0,
++               "MPENTRY_PADDR is not page-aligned");
+ }
+ 
+ //
+@@ -491,20 +515,6 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
+ 		*pag = physical | perm | PTE_P;
+ 	}
+ #else
+-	/*for(int i = 0; i < size; i+= PGSIZE)
+-	{
+-	        uintptr_t virtual = va + i;
+-	        physaddr_t physical = pa + i;
+-	        if( ((virtual % PTSIZE) == 0) && (size >= PTSIZE) )//&& (size % PTSIZE == 0) )
+-	        {
+-	                pgdir[PDX(virtual)] = physical | perm | PTE_P | PTE_PS;
+-	        }
+-	        else
+-	        {
+-	                pte_t *pag = pgdir_walk(pgdir, (const void*) virtual , 1);
+-	                *pag = physical | perm | PTE_P;
+-	        }
+-	}*/
+ 	while (size >= PGSIZE) {
+ 		if ((va % PTSIZE == 0) && (size >= PTSIZE) &&
+ 		    (pa % PTSIZE == 0))  //&& (size % PTSIZE == 0) )
+@@ -653,7 +663,11 @@ mmio_map_region(physaddr_t pa, size_t size)
+ 	// beginning of the MMIO region.  Because this is static, its
+ 	// value will be preserved between calls to mmio_map_region
+ 	// (just like nextfree in boot_alloc).
+-	static uintptr_t base = MMIOBASE;
++	static uintptr_t base;
++	if(base == 0) {
++		// cprintf("Entre al if");
++		base = MMIOBASE;
++	}
+ 
+ 	// Reserve size bytes of virtual memory starting at base and
+ 	// map physical pages [pa,pa+size) to virtual addresses
+@@ -673,7 +687,20 @@ mmio_map_region(physaddr_t pa, size_t size)
+ 	// Hint: The staff solution uses boot_map_region.
+ 	//
+ 	// Your code here:
+-	panic("mmio_map_region not implemented");
++
++	size_t round_size = ROUNDUP(size, PGSIZE);
++	if ( (base + round_size) > MMIOLIM)
++		panic("mmio_map_region is trying to overflow MMIOLIM");
++
++	boot_map_region(kern_pgdir,
++		base,
++		round_size,
++		pa,
++		PTE_PCD | PTE_PWT | PTE_W | PTE_P);
++
++	void* baseViejo = (void*) base;
++	base = (uintptr_t) (base + round_size);
++	return baseViejo;
+ }
+ 
+ static uintptr_t user_mem_check_addr;
+diff --git a/kern/sched.c b/kern/sched.c
+index 7726e32..80bc9e5 100644
+--- a/kern/sched.c
++++ b/kern/sched.c
+@@ -1,3 +1,4 @@
++
+ #include <inc/assert.h>
+ #include <inc/x86.h>
+ #include <kern/spinlock.h>
+@@ -10,8 +11,9 @@ void sched_halt(void);
+ // Choose a user environment to run and run it.
+ void
+ sched_yield(void)
+-{
++{	
+ 	struct Env *idle;
++	int idx;
+ 
+ 	// Implement simple round-robin scheduling.
+ 	//
+@@ -27,9 +29,45 @@ sched_yield(void)
+ 	// another CPU (env_status == ENV_RUNNING). If there are
+ 	// no runnable environments, simply drop through to the code
+ 	// below to halt the cpu.
+-
+ 	// LAB 4: Your code here.
++	if(!curenv)
++	{
++		idle =  &envs[0];
++		idx = 0;
++	}
++	else{
++		idle = curenv;
++		idx = (curenv - envs) + 1;
++	}
++
++	int iterations = 0;
++	//cprintf("Empiezo la iteracion.\n");
++	while(iterations < (NENV-1) )
++	{	// tengo otro proceso runnable? si es así, lo uso
++		
++		// cprintf("iteracion %d, indice %d\n", iterations, idx);
++		if(envs[idx].env_status == ENV_RUNNABLE)
++		{
++			if(curenv != NULL) {
++				//cprintf("Set al curenv environment en Runnable. Esto implica que voy a correr otro\n");
++				curenv->env_status = ENV_RUNNABLE;
++			}
++			//cprintf("Env run, iteracion %d\n", iterations);
++			env_run(&envs[idx]);
++		}
++
++		iterations++;
++		idx++;
++		if(idx == NENV) {
++			//cprintf("reseteo el idx.\n");
++			idx = 0;
++		}
++	}
++	 // sino le vuelvo a dar el time slice al que estaba corriendo
++	if(idle->env_status == ENV_RUNNING)
++		env_run(idle);
+ 
++	// else, si no esta running y no tengo ninguno runnable, entonces voy a sched_halt
+ 	// sched_halt never returns
+ 	sched_halt();
+ }
+diff --git a/kern/syscall.c b/kern/syscall.c
+index e98ae08..194473d 100644
+--- a/kern/syscall.c
++++ b/kern/syscall.c
+@@ -68,6 +68,8 @@ sys_env_destroy(envid_t envid)
+ static void
+ sys_yield(void)
+ {
++	// Cambiamos esto...
++	// curenv->env_status = ENV_RUNNABLE;
+ 	sched_yield();
+ }
+ 
+@@ -85,7 +87,19 @@ sys_exofork(void)
+ 	// will appear to return 0.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_exofork not implemented");
++	
++	struct Env *e;
++	int resultado = env_alloc(&e, thiscpu->cpu_env->env_id);
++	if(resultado < 0)	// ambos errores contemplados en env_alloc
++		return resultado;
++
++	//e->env_tf.tf_regs = thiscpu->cpu_env->env_tf.tf_regs;
++	e->env_tf = thiscpu->cpu_env->env_tf;
++	e->env_tf.tf_regs.reg_eax = 0;
++	e->env_status = ENV_NOT_RUNNABLE;
++
++	// int prueba = e->env_id;
++	return (e->env_id);
+ }
+ 
+ // Set envid's env_status to status, which must be ENV_RUNNABLE
+@@ -105,7 +119,18 @@ sys_env_set_status(envid_t envid, int status)
+ 	// envid's status.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_env_set_status not implemented");
++
++	if( (status != ENV_RUNNABLE) && (status != ENV_NOT_RUNNABLE) )
++		return -E_INVAL;
++
++	struct Env *e;
++	int resultado = envid2env(envid, &e, 1);
++	if (resultado < 0)
++		return resultado;	// esto es -E_BAD_ENV
++
++	// si llegamos hasta acá salió todo bien. Cambio el status
++	e->env_status = status;
++	return 0;
+ }
+ 
+ // Set the page fault upcall for 'envid' by modifying the corresponding struct
+@@ -150,7 +175,29 @@ sys_page_alloc(envid_t envid, void *va, int perm)
+ 	//   allocated!
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_alloc not implemented");
++	//panic("sys_page_alloc not implemented");
++
++	if( ((uint32_t)va >= UTOP) || ((uint32_t)va % PGSIZE != 0) )
++		return -E_INVAL;
++	if( (perm & (PTE_U|PTE_P)) != (PTE_U|PTE_P) )
++		return -E_INVAL;
++
++	struct Env* e;
++	int resultado = envid2env(envid, &e, 1);
++	if (resultado < 0)
++		return resultado;
++
++	struct PageInfo *page = page_alloc(ALLOC_ZERO);
++	if(!page)
++		return -E_NO_MEM;
++
++	resultado = page_insert(e->env_pgdir, page, va, perm);
++	if(resultado < 0) {
++		page_free(page);
++		return -E_NO_MEM;
++	}
++
++	return 0;
+ }
+ 
+ // Map the page of memory at 'srcva' in srcenvid's address space
+@@ -180,7 +227,37 @@ sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int p
+ 	//   check the current permissions on the page.
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_map not implemented");
++	if( ((uint32_t)srcva >= UTOP) || ((uint32_t)srcva % PGSIZE != 0) )
++		return -E_INVAL;
++	if( ((uint32_t)dstva >= UTOP) || ((uint32_t)dstva % PGSIZE != 0) )
++		return -E_INVAL;
++	// mismo chequeo de permisos que en sys_page_alloc
++	if( (perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P) )
++		return -E_INVAL;
++
++	struct Env *srcenv;
++	struct Env *dstenv;
++	int res1 = envid2env(srcenvid, &srcenv, 1);
++	int res2 = envid2env(dstenvid, &dstenv, 1);
++	if( (res1 < 0) || (res2 < 0) )
++		return -E_BAD_ENV;
++
++	pte_t* pte;
++
++	struct PageInfo* page = page_lookup(srcenv->env_pgdir, srcva, &pte);
++	if(!page)
++		-E_INVAL;
++	
++	//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
++	//		address space.
++	if( ((*pte & PTE_W) == 0) && ((perm & PTE_W) == PTE_W) )
++		return -E_INVAL;
++
++	res1 = page_insert(dstenv->env_pgdir, page, dstva, perm);
++	if(res1 < 0)
++		return -E_NO_MEM;
++
++	return 0;
+ }
+ 
+ // Unmap the page of memory at 'va' in the address space of 'envid'.
+@@ -196,7 +273,15 @@ sys_page_unmap(envid_t envid, void *va)
+ 	// Hint: This function is a wrapper around page_remove().
+ 
+ 	// LAB 4: Your code here.
+-	panic("sys_page_unmap not implemented");
++	if( (uint32_t)va >= UTOP )
++		return -E_INVAL;
++	struct Env *e;
++	int res = envid2env(envid, &e, 1);
++	if (res < 0)
++		return -E_BAD_ENV;
++
++	page_remove(e->env_pgdir, va);
++	return 0;
+ }
+ 
+ // Try to send 'value' to the target env 'envid'.
+@@ -270,7 +355,7 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
+ 	// Call the function corresponding to the 'syscallno' parameter.
+ 	// Return any appropriate return value.
+ 	// LAB 3: Your code here.
+-	int ret = 0;
++	int ret = 0;	// código de error arbitrario?
+ 	switch (syscallno) {
+ 	case SYS_cputs:
+ 		sys_cputs((char *) a1, a2);
+@@ -286,6 +371,26 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
+ 		sys_env_destroy(a1);
+ 		ret = 0;
+ 		break;
++	case SYS_exofork:
++		ret = sys_exofork();
++		break;
++	case SYS_page_alloc:
++		ret = sys_page_alloc((envid_t) a1, (void*) a2, (int32_t) a3);
++		break;
++	case SYS_env_set_status:
++		ret = sys_env_set_status( (envid_t) a1, (int32_t) a2);
++		int prueba = ret;
++		break;
++	case SYS_page_map:
++		ret = sys_page_map((envid_t) a1, (void*) a2, (envid_t) a3, (void*) a4, (int32_t)a5);
++		break;
++	case SYS_page_unmap:
++		ret = sys_page_unmap( (envid_t) a1, (void*) a2);
++		break;
++	case SYS_yield:
++		sys_yield();
++		break;
++
+ 	default:
+ 		ret = -E_INVAL;
+ 	}
+diff --git a/kern/trap.c b/kern/trap.c
+index 6c47a98..f16ddb4 100644
+--- a/kern/trap.c
++++ b/kern/trap.c
+@@ -14,7 +14,7 @@
+ #include <kern/cpu.h>
+ #include <kern/spinlock.h>
+ 
+-static struct Taskstate ts;
++// tatic struct Taskstate ts;
+ 
+ /* For debugging, so print_trapframe can distinguish between printing
+  * a saved trapframe and printing the current trapframe and print some
+@@ -92,6 +92,7 @@ trap_init(void)
+ 	void trap_handler_18();
+ 	void trap_handler_19();
+ 	void trap_handler_20();
++	void trap_handler_32();
+ 	void trap_handler_48();
+ 
+ 	SETGATE(idt[0], 0, GD_KT, trap_handler_0, 0);
+@@ -119,6 +120,10 @@ trap_init(void)
+ 	SETGATE(idt[18], 0, GD_KT, trap_handler_18, 0);
+ 	SETGATE(idt[19], 0, GD_KT, trap_handler_19, 0);
+ 	SETGATE(idt[20], 0, GD_KT, trap_handler_20, 0);
++
++	//IRQ_TIMER
++	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], 0, GD_KT, trap_handler_32, 0);
++
+ 	SETGATE(idt[48], 0, GD_KT, trap_handler_48, 3);
+ 
+ 
+@@ -155,18 +160,27 @@ trap_init_percpu(void)
+ 
+ 	// Setup a TSS so that we get the right stack
+ 	// when we trap to the kernel.
+-	ts.ts_esp0 = KSTACKTOP;
+-	ts.ts_ss0 = GD_KD;
+-	ts.ts_iomb = sizeof(struct Taskstate);
++
++	int id = cpunum();
++	struct CpuInfo *cpu = &cpus[id];
++	struct Taskstate *ts = &cpu->cpu_ts;
++
++	uintptr_t ts_stack = (KSTACKTOP) - id * (KSTKSIZE + KSTKGAP);
++
++	ts->ts_esp0 = ts_stack;
++	ts->ts_ss0 = GD_KD;
++	ts->ts_iomb = sizeof(struct Taskstate);
+ 
+ 	// Initialize the TSS slot of the gdt.
+-	gdt[GD_TSS0 >> 3] =
+-	        SEG16(STS_T32A, (uint32_t)(&ts), sizeof(struct Taskstate) - 1, 0);
+-	gdt[GD_TSS0 >> 3].sd_s = 0;
++	uint16_t idx = (GD_TSS0 >> 3) + id;
++	gdt[idx] =
++	        SEG16(STS_T32A, (uint32_t)(ts), sizeof(struct Taskstate) - 1, 0);
++	gdt[idx].sd_s = 0;
+ 
+ 	// Load the TSS selector (like other segment selectors, the
+ 	// bottom three bits are special; we leave them 0)
+-	ltr(GD_TSS0);
++	uint16_t seg = idx << 3;
++	ltr(seg);
+ 
+ 	// Load the IDT
+ 	lidt(&idt_pd);
+@@ -255,6 +269,11 @@ trap_dispatch(struct Trapframe *tf)
+ 	// Handle clock interrupts. Don't forget to acknowledge the
+ 	// interrupt using lapic_eoi() before calling the scheduler!
+ 	// LAB 4: Your code here.
++	if ( (tf->tf_eflags & FL_IF) == FL_IF) {
++		// cprintf("Estoy en FL_IF");
++		lapic_eoi();
++		sched_yield();
++	}
+ 
+ 	// Unexpected trap: The user process or the kernel has a bug.
+ 	print_trapframe(tf);
+@@ -292,6 +311,7 @@ trap(struct Trapframe *tf)
+ 		// Acquire the big kernel lock before doing any
+ 		// serious kernel work.
+ 		// LAB 4: Your code here.
++		lock_kernel();
+ 		assert(curenv);
+ 
+ 		// Garbage collect if current enviroment is a zombie
+diff --git a/kern/trapentry.S b/kern/trapentry.S
+index bf2223b..38beb58 100644
+--- a/kern/trapentry.S
++++ b/kern/trapentry.S
+@@ -72,6 +72,8 @@ TRAPHANDLER_NOEC(trap_handler_18, 18);
+ TRAPHANDLER_NOEC(trap_handler_19, 19);
+ TRAPHANDLER_NOEC(trap_handler_20, 20);
+ 
++//IRQ TIMER
++TRAPHANDLER_NOEC(trap_handler_32, 32);
+ TRAPHANDLER_NOEC(trap_handler_48, 48);
+ /*
+  * Lab 3: Your code here for _alltraps
+diff --git a/lib/fork.c b/lib/fork.c
+index d32749e..6ee2194 100644
+--- a/lib/fork.c
++++ b/lib/fork.c
+@@ -58,6 +58,60 @@ duppage(envid_t envid, unsigned pn)
+ 	return 0;
+ }
+ 
++static void
++dup_or_share(envid_t dstenv, void *va, int perm)
++{
++	int r;
++
++	if( perm & PTE_W )
++	{
++		if ((r = sys_page_alloc(dstenv, va, perm)) < 0)
++		panic("sys_page_alloc: %e", r);
++	}
++	if ((r = sys_page_map(dstenv, va, 0, UTEMP, perm)) < 0)
++		panic("sys_page_map: %e", r);
++	memmove(UTEMP, va, PGSIZE);
++	if ((r = sys_page_unmap(0, UTEMP)) < 0)
++		panic("sys_page_unmap: %e", r);
++	
++}
++
++
++envid_t fork_v0(void)
++{
++	envid_t envid;
++
++	envid = sys_exofork();
++	if(envid < 0)
++	{
++		panic("sys_exofork: %e", envid);
++	}
++	if(envid == 0) //Hijo
++	{
++
++		//if(sys_env_set_status(thisenv->env_id, ENV_RUNNABLE) < 0)
++		//	panic("sys_env_set_status en fork_v0\n");
++		thisenv = &envs[ENVX(sys_getenvid())];
++		return 0;
++	}
++
++	//Padre
++
++	uint32_t va;
++	for(va = 0; va < UTOP; va += PGSIZE)
++	{
++		if( (uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_U) )
++			dup_or_share(envid, (void*) va, uvpt[PGNUM(va)] & PTE_SYSCALL);
++	}
++
++	// Start the child environment running
++	if( sys_env_set_status(envid, ENV_RUNNABLE) < 0) 
++		panic("sys_env_set_status");
++	// cprintf("Seteamos el status del hijo\n");
++	
++	return envid;
++}
++
+ //
+ // User-level fork with copy-on-write.
+ // Set up our page fault handler appropriately.
+@@ -77,10 +131,11 @@ duppage(envid_t envid, unsigned pn)
+ envid_t
+ fork(void)
+ {
+-	// LAB 4: Your code here.
+-	panic("fork not implemented");
++	return fork_v0();
++	// panic("fork not implemented");
+ }
+ 
++
+ // Challenge!
+ int
+ sfork(void)
+diff --git a/user/dumbfork.c b/user/dumbfork.c
+index e5e433c..6442da2 100644
+--- a/user/dumbfork.c
++++ b/user/dumbfork.c
+@@ -18,6 +18,8 @@ umain(int argc, char **argv)
+ 	// print a message and yield to the other a few times
+ 	for (i = 0; i < (who ? 10 : 20); i++) {
+ 		cprintf("%d: I am the %s!\n", i, who ? "parent" : "child");
++		int32_t id = (int32_t) sys_getenvid();
++		cprintf("El envid es %d\n", id);
+ 		sys_yield();
+ 	}
+ }
+diff --git a/user/yield.c b/user/yield.c
+index 6f45bdb..ed7ea16 100644
+--- a/user/yield.c
++++ b/user/yield.c
+@@ -7,11 +7,11 @@ umain(int argc, char **argv)
+ {
+ 	int i;
+ 
+-	cprintf("Hello, I am environment %08x.\n", thisenv->env_id);
++	cprintf("Hello, I am environment %08x, cpu %d\n", thisenv->env_id, thisenv->env_cpunum);
+ 	for (i = 0; i < 5; i++) {
+ 		sys_yield();
+-		cprintf("Back in environment %08x, iteration %d.\n",
+-			thisenv->env_id, i);
++		cprintf("Back in environment %08x, iteration %d, cpu %d\n",
++			thisenv->env_id, i, thisenv->env_cpunum);
+ 	}
+ 	cprintf("All done in environment %08x.\n", thisenv->env_id);
+ }
diff --git a/grade-lab4 b/grade-lab4
index 91e52b4..38b4daf 100755
--- a/grade-lab4
+++ b/grade-lab4
@@ -40,7 +40,7 @@ def test_yield():
 
 @test(1)
 def test_spin0():
-    r.user_test("spin0", timeout=0.5)
+    r.user_test("spin0", timeout=1)
     r.match(E(".00000000. new env $E1"),
             E(".00000000. new env $E2"),
             E("I am $E1 and my spin will go on #1"),
diff --git a/inc/env.h b/inc/env.h
index 38ca0f9..defafba 100644
--- a/inc/env.h
+++ b/inc/env.h
@@ -33,8 +33,8 @@ typedef int32_t envid_t;
 enum {
 	ENV_FREE = 0,
 	ENV_DYING,
-	ENV_RUNNABLE,
-	ENV_RUNNING,
+	ENV_RUNNABLE = 20,
+	ENV_RUNNING = 30,
 	ENV_NOT_RUNNABLE
 };
 
diff --git a/kern/entry.S b/kern/entry.S
index c282a35..32403e3 100644
--- a/kern/entry.S
+++ b/kern/entry.S
@@ -57,20 +57,12 @@ entry:
 	# Load the physical address of entry_pgdir into cr3.  entry_pgdir
 	# is defined in entrypgdir.c.
 	movl	$(RELOC(entry_pgdir)), %eax
-	//orl		$PTE_PS, %eax
 	movl	%eax, %cr3
 
 	movl	%cr4, %eax
 	orl		$CR4_PSE, %eax
 	movl	%eax, %cr4
 
-	# Realmente se supone que esto es habilitar large pages????
-	# la concha de tu madre jos
-	// movl 	%cr4, %eax
-	// movl	$(RELOC(entry_pgdir)), %eax
-	// orl		$PTE_PS, %eax
-	// movl	%eax, %cr4
-
 	# Turn on paging.
 	movl	%cr0, %eax
 	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax
diff --git a/kern/env.c b/kern/env.c
index 25c97b3..e405716 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -416,6 +416,8 @@ env_create(uint8_t *binary, enum EnvType type)
 	if (err < 0)
 		panic("env_create: %e", err);
 
+	// habilito FL_IF para IRQ_TIMER
+	env->env_tf.tf_eflags = FL_IF;
 	env->env_type = type;
 	load_icode(env, binary);
 }
@@ -551,13 +553,17 @@ env_run(struct Env *e)
 	// LAB 3: Your code here.
 
 	// Step 1:
-	if (e != curenv) {
-		curenv = e;
-		e->env_status = ENV_RUNNING;
-		e->env_runs++;
-		lcr3(PADDR(e->env_pgdir));
+	if((curenv != NULL) && (curenv->env_status == ENV_RUNNING)) 
+	{
+		curenv->env_status = ENV_RUNNABLE;
 	}
 
+	curenv = e;
+	curenv->env_status = ENV_RUNNING;
+	curenv->env_runs++;
+	lcr3(PADDR(e->env_pgdir));
+	
+	unlock_kernel();
 	env_pop_tf(&e->env_tf);
 
 	// panic("env_run not yet implemented");
diff --git a/kern/init.c b/kern/init.c
index 3c83f7d..496f162 100644
--- a/kern/init.c
+++ b/kern/init.c
@@ -50,6 +50,7 @@ i386_init(void)
 
 	// Acquire the big kernel lock before waking up APs
 	// Your code here:
+	lock_kernel();
 
 	// Starting non-boot CPUs
 	boot_aps();
@@ -68,14 +69,17 @@ i386_init(void)
 		ENV_CREATE(TEST, ENV_TYPE_USER);
 #else
 	// Touch all you want.
-	ENV_CREATE(user_hello, ENV_TYPE_USER);
-	ENV_CREATE(user_hello, ENV_TYPE_USER);
-	ENV_CREATE(user_hello, ENV_TYPE_USER);
+	// 	ENV_CREATE(user_hello, ENV_TYPE_USER);
+	// 	ENV_CREATE(user_yield, ENV_TYPE_USER);
+	ENV_CREATE(user_forktree, ENV_TYPE_USER);
+	//ENV_CREATE(user_stresssched, ENV_TYPE_USER);
+	//ENV_CREATE(user_hello, ENV_TYPE_USER);
+	//ENV_CREATE(user_hello, ENV_TYPE_USER);
 #endif // TEST*
 
 	// Eliminar esta llamada una vez completada la parte 1
 	// e implementado sched_yield().
-	env_run(&envs[0]);
+	//env_run(&envs[0]);
 
 	// Schedule and run the first user environment!
 	sched_yield();
@@ -92,8 +96,8 @@ boot_aps(void)
 {
 	extern unsigned char mpentry_start[], mpentry_end[];
 	void *code;
-	struct CpuInfo *c;
-
+	struct CpuInfo *c
+;
 	// Write entry code to unused memory at MPENTRY_PADDR
 	code = KADDR(MPENTRY_PADDR);
 	memmove(code, mpentry_start, mpentry_end - mpentry_start);
@@ -131,9 +135,11 @@ mp_main(void)
 	// only one CPU can enter the scheduler at a time!
 	//
 	// Your code here:
+	lock_kernel();
+	sched_yield();
 
 	// Remove this after you finish Exercise 4
-	for (;;);
+	// for (;;);
 }
 
 /*
diff --git a/kern/mpentry.S b/kern/mpentry.S
index 72dd827..92a310a 100644
--- a/kern/mpentry.S
+++ b/kern/mpentry.S
@@ -64,6 +64,12 @@ start32:
 	# we are still running at a low EIP.
 	movl    $(RELOC(entry_pgdir)), %eax
 	movl    %eax, %cr3
+
+	# Large Pages (extensión PSE)
+	movl	%cr4, %eax
+	orl		$CR4_PSE, %eax
+	movl	%eax, %cr4
+
 	# Turn on paging.
 	movl    %cr0, %eax
 	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
diff --git a/kern/pmap.c b/kern/pmap.c
index 2befc29..9fb15c9 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -299,6 +299,16 @@ mem_init_mp(void)
 	//     Permissions: kernel RW, user NONE
 	//
 	// LAB 4: Your code here:
+	uintptr_t start = KSTACKTOP - KSTKSIZE;
+	for(int i = 0; i < NCPU; i++)
+	{
+		boot_map_region(kern_pgdir,
+	            start - i * (KSTKSIZE + KSTKGAP),
+	            KSTKSIZE,
+	            PADDR(&percpu_kstacks[i]),
+	            PTE_W | PTE_P);
+	}
+
 }
 
 // --------------------------------------------------------------
@@ -319,6 +329,10 @@ page_init(void)
 	// LAB 4:
 	// Change your code to mark the physical page at MPENTRY_PADDR
 	// as in use
+	int indice = PGNUM(MPENTRY_PADDR);
+	cprintf("indice MPENTRY_PADDR: %d\n", indice);
+	cprintf("indice npages_basemem: %d\n", npages_basemem);
+
 
 	// The example code here marks all physical pages as free.
 	// However this is not truly the case.  What memory is free?
@@ -341,6 +355,13 @@ page_init(void)
 	for (i = 1; i < npages_basemem;
 	     i++) {  // Este for lo que hace es generar la lista enlazada de las
 		     // paginas. pages[i].pp_link guarda la direccion de la pagina anterior (pages[i-1])
+		//pages[i].pp_ref = 0;
+
+		if(i == indice) {
+			//pages[i].pp_link = NULL;
+			continue;
+		}	
+
 		pages[i].pp_ref = 0;
 		pages[i].pp_link = page_free_list;
 		page_free_list = &pages[i];
@@ -356,6 +377,9 @@ page_init(void)
 		pages[i].pp_link = page_free_list;
 		page_free_list = &pages[i];
 	}
+
+	_Static_assert(MPENTRY_PADDR % PGSIZE == 0,
+               "MPENTRY_PADDR is not page-aligned");
 }
 
 //
@@ -491,20 +515,6 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
 		*pag = physical | perm | PTE_P;
 	}
 #else
-	/*for(int i = 0; i < size; i+= PGSIZE)
-	{
-	        uintptr_t virtual = va + i;
-	        physaddr_t physical = pa + i;
-	        if( ((virtual % PTSIZE) == 0) && (size >= PTSIZE) )//&& (size % PTSIZE == 0) )
-	        {
-	                pgdir[PDX(virtual)] = physical | perm | PTE_P | PTE_PS;
-	        }
-	        else
-	        {
-	                pte_t *pag = pgdir_walk(pgdir, (const void*) virtual , 1);
-	                *pag = physical | perm | PTE_P;
-	        }
-	}*/
 	while (size >= PGSIZE) {
 		if ((va % PTSIZE == 0) && (size >= PTSIZE) &&
 		    (pa % PTSIZE == 0))  //&& (size % PTSIZE == 0) )
@@ -653,7 +663,11 @@ mmio_map_region(physaddr_t pa, size_t size)
 	// beginning of the MMIO region.  Because this is static, its
 	// value will be preserved between calls to mmio_map_region
 	// (just like nextfree in boot_alloc).
-	static uintptr_t base = MMIOBASE;
+	static uintptr_t base;
+	if(base == 0) {
+		// cprintf("Entre al if");
+		base = MMIOBASE;
+	}
 
 	// Reserve size bytes of virtual memory starting at base and
 	// map physical pages [pa,pa+size) to virtual addresses
@@ -673,7 +687,20 @@ mmio_map_region(physaddr_t pa, size_t size)
 	// Hint: The staff solution uses boot_map_region.
 	//
 	// Your code here:
-	panic("mmio_map_region not implemented");
+
+	size_t round_size = ROUNDUP(size, PGSIZE);
+	if ( (base + round_size) > MMIOLIM)
+		panic("mmio_map_region is trying to overflow MMIOLIM");
+
+	boot_map_region(kern_pgdir,
+		base,
+		round_size,
+		pa,
+		PTE_PCD | PTE_PWT | PTE_W | PTE_P);
+
+	void* baseViejo = (void*) base;
+	base = (uintptr_t) (base + round_size);
+	return baseViejo;
 }
 
 static uintptr_t user_mem_check_addr;
@@ -708,7 +735,7 @@ user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 	for (void *i = direccionInicial; i < direccionFinal; i += PGSIZE) {
 		// chequea si el user program puede acceder a la memoria virtual i
 		pte_t *pte = pgdir_walk(env->env_pgdir, i, 0);
-		if (((int) i > ULIM) || ((*pte & this_perm) != this_perm)) {
+		if ( ((int) i > ULIM) || (pte == NULL) || ((*pte & this_perm) != this_perm) )  {
 			if (i < va)
 				user_mem_check_addr = (uintptr_t) va;
 			else
diff --git a/kern/sched.c b/kern/sched.c
index 7726e32..0308a07 100644
--- a/kern/sched.c
+++ b/kern/sched.c
@@ -1,3 +1,4 @@
+
 #include <inc/assert.h>
 #include <inc/x86.h>
 #include <kern/spinlock.h>
@@ -10,8 +11,9 @@ void sched_halt(void);
 // Choose a user environment to run and run it.
 void
 sched_yield(void)
-{
+{	
 	struct Env *idle;
+	int idx;
 
 	// Implement simple round-robin scheduling.
 	//
@@ -27,9 +29,45 @@ sched_yield(void)
 	// another CPU (env_status == ENV_RUNNING). If there are
 	// no runnable environments, simply drop through to the code
 	// below to halt the cpu.
-
 	// LAB 4: Your code here.
+	if(!curenv)
+	{
+		idle =  &envs[0];
+		idx = 0;
+	}
+	else{
+		idle = curenv;
+		idx = (curenv - envs) + 1;
+	}
+
+	int iterations = 0;
+	//cprintf("Empiezo la iteracion.\n");
+	while(iterations < (NENV-1) )
+	{	// tengo otro proceso runnable? si es así, lo uso
+		
+		// cprintf("iteracion %d, indice %d\n", iterations, idx);
+		if(envs[idx].env_status == ENV_RUNNABLE)
+		{
+			//if(curenv != NULL) {
+				//cprintf("Set al curenv environment en Runnable. Esto implica que voy a correr otro\n");
+				//curenv->env_status = ENV_RUNNABLE;
+			//}
+			//cprintf("Env run, iteracion %d\n", iterations);
+			env_run(&envs[idx]);
+		}
+
+		iterations++;
+		idx++;
+		if(idx == NENV) {
+			//cprintf("reseteo el idx.\n");
+			idx = 0;
+		}
+	}
+	 // sino le vuelvo a dar el time slice al que estaba corriendo
+	if (curenv && curenv->env_status == ENV_RUNNING)
+    	env_run(curenv);
 
+	// else, si no esta running y no tengo ninguno runnable, entonces voy a sched_halt
 	// sched_halt never returns
 	sched_halt();
 }
diff --git a/kern/syscall.c b/kern/syscall.c
index e98ae08..754421d 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -68,6 +68,8 @@ sys_env_destroy(envid_t envid)
 static void
 sys_yield(void)
 {
+	// Cambiamos esto...
+	// curenv->env_status = ENV_RUNNABLE;
 	sched_yield();
 }
 
@@ -85,7 +87,19 @@ sys_exofork(void)
 	// will appear to return 0.
 
 	// LAB 4: Your code here.
-	panic("sys_exofork not implemented");
+	
+	struct Env *e;
+	int resultado = env_alloc(&e, thiscpu->cpu_env->env_id);
+	if(resultado < 0)	// ambos errores contemplados en env_alloc
+		return resultado;
+
+	//e->env_tf.tf_regs = thiscpu->cpu_env->env_tf.tf_regs;
+	e->env_tf = thiscpu->cpu_env->env_tf;
+	e->env_tf.tf_regs.reg_eax = 0;
+	e->env_status = ENV_NOT_RUNNABLE;
+
+	// int prueba = e->env_id;
+	return (e->env_id);
 }
 
 // Set envid's env_status to status, which must be ENV_RUNNABLE
@@ -105,7 +119,18 @@ sys_env_set_status(envid_t envid, int status)
 	// envid's status.
 
 	// LAB 4: Your code here.
-	panic("sys_env_set_status not implemented");
+
+	if( (status != ENV_RUNNABLE) && (status != ENV_NOT_RUNNABLE) )
+		return -E_INVAL;
+
+	struct Env *e;
+	int resultado = envid2env(envid, &e, 1);
+	if (resultado < 0)
+		return resultado;	// esto es -E_BAD_ENV
+
+	// si llegamos hasta acá salió todo bien. Cambio el status
+	e->env_status = status;
+	return 0;
 }
 
 // Set the page fault upcall for 'envid' by modifying the corresponding struct
@@ -120,7 +145,14 @@ static int
 sys_env_set_pgfault_upcall(envid_t envid, void *func)
 {
 	// LAB 4: Your code here.
-	panic("sys_env_set_pgfault_upcall not implemented");
+	//panic("sys_env_set_pgfault_upcall not implemented");
+
+	struct Env* e;
+	if(envid2env(envid, &e, 1) < 0)
+		return -E_BAD_ENV;
+
+	e->env_pgfault_upcall = func;
+	return 0;
 }
 
 // Allocate a page of memory and map it at 'va' with permission
@@ -150,7 +182,29 @@ sys_page_alloc(envid_t envid, void *va, int perm)
 	//   allocated!
 
 	// LAB 4: Your code here.
-	panic("sys_page_alloc not implemented");
+	//panic("sys_page_alloc not implemented");
+
+	if( ((uint32_t)va >= UTOP) || ((uint32_t)va % PGSIZE != 0) )
+		return -E_INVAL;
+	if( (perm & (PTE_U|PTE_P)) != (PTE_U|PTE_P) )
+		return -E_INVAL;
+
+	struct Env* e;
+	int resultado = envid2env(envid, &e, 1);
+	if (resultado < 0)
+		return resultado;
+
+	struct PageInfo *page = page_alloc(ALLOC_ZERO);
+	if(!page)
+		return -E_NO_MEM;
+
+	resultado = page_insert(e->env_pgdir, page, va, perm);
+	if(resultado < 0) {
+		page_free(page);
+		return -E_NO_MEM;
+	}
+
+	return 0;
 }
 
 // Map the page of memory at 'srcva' in srcenvid's address space
@@ -170,7 +224,7 @@ sys_page_alloc(envid_t envid, void *va, int perm)
 //		address space.
 //	-E_NO_MEM if there's no memory to allocate any necessary page tables.
 static int
-sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int perm)
+sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int perm, bool protection)
 {
 	// Hint: This function is a wrapper around page_lookup() and
 	//   page_insert() from kern/pmap.c.
@@ -180,7 +234,48 @@ sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int p
 	//   check the current permissions on the page.
 
 	// LAB 4: Your code here.
-	panic("sys_page_map not implemented");
+	if( ((uint32_t)srcva >= UTOP) || ((uint32_t)srcva % PGSIZE != 0) )
+		return -E_INVAL;
+	if( ((uint32_t)dstva >= UTOP) || ((uint32_t)dstva % PGSIZE != 0) )
+		return -E_INVAL;
+	// mismo chequeo de permisos que en sys_page_alloc
+	if( (perm & (PTE_U | PTE_P)) != (PTE_U | PTE_P) )
+		return -E_INVAL;
+
+	struct Env *srcenv;
+	struct Env *dstenv;
+	int res1, res2;
+	if( !protection )
+	{
+		res1 = envid2env(srcenvid, &srcenv, 0);
+		res2 = envid2env(dstenvid, &dstenv, 0);
+	}
+	else
+	{
+		res1 = envid2env(srcenvid, &srcenv, 1);
+		res2 = envid2env(dstenvid, &dstenv, 1);
+	}
+	if( (res1 < 0) || (res2 < 0) )
+		return -E_BAD_ENV;
+
+	pte_t* pte;
+
+	struct PageInfo* page = page_lookup(srcenv->env_pgdir, srcva, &pte);
+	if(page == NULL) {
+		cprintf("sabes que sí\n");
+		return -E_INVAL;
+	}
+	
+	//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
+	//		address space.
+	if( ((*pte & PTE_W) == 0) && ((perm & PTE_W) == PTE_W) )
+		return -E_INVAL;
+
+	res1 = page_insert(dstenv->env_pgdir, page, dstva, perm);
+	if(res1 < 0)
+		return -E_NO_MEM;
+
+	return 0;
 }
 
 // Unmap the page of memory at 'va' in the address space of 'envid'.
@@ -196,7 +291,15 @@ sys_page_unmap(envid_t envid, void *va)
 	// Hint: This function is a wrapper around page_remove().
 
 	// LAB 4: Your code here.
-	panic("sys_page_unmap not implemented");
+	if( (uint32_t)va >= UTOP )
+		return -E_INVAL;
+	struct Env *e;
+	int res = envid2env(envid, &e, 1);
+	if (res < 0)
+		return -E_BAD_ENV;
+
+	page_remove(e->env_pgdir, va);
+	return 0;
 }
 
 // Try to send 'value' to the target env 'envid'.
@@ -241,7 +344,60 @@ static int
 sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
 {
 	// LAB 4: Your code here.
-	panic("sys_ipc_try_send not implemented");
+	struct Env* e;
+	//cprintf("NADA");
+	if( envid2env(envid, &e, 0) < 0)
+		return -E_BAD_ENV;
+
+	//cprintf("aca 0");
+	if(e->env_ipc_recving == false)
+		return -E_IPC_NOT_RECV;
+
+	//cprintf("aca 1");
+	if( (srcva < (void*)UTOP) && (((int)srcva % PGSIZE) != 0) )
+		return -E_INVAL;
+
+	pte_t* pte;
+	struct PageInfo* page;
+	page = page_lookup(curenv->env_pgdir, srcva, &pte);
+
+	//cprintf("aca 2");
+	if( (srcva < (void*)UTOP) && ((*pte & perm) != perm) )
+		return -E_INVAL;
+
+	//cprintf("aca 3");	
+	if( (srcva < (void*)UTOP) && (!page) )
+		return -E_INVAL;
+
+	//cprintf("aca 4");
+	if( (srcva < (void*)UTOP) && ((perm & PTE_W) && !(*pte & PTE_W)) )
+		return -E_INVAL;
+
+	//cprintf("aca 5");
+	if( (srcva < (void*)UTOP) && (e->env_ipc_dstva < (void*)UTOP) )
+	{
+		if( sys_page_map(curenv->env_id, srcva, envid, e->env_ipc_dstva, perm, 0) < 0 )	
+		{	
+			return -E_NO_MEM;
+		}
+		else
+		{
+			e->env_ipc_perm = perm;
+		}
+	}
+	else
+	{
+		e->env_ipc_perm = 0;
+	}
+
+	e->env_ipc_recving = false;
+	e->env_ipc_from = curenv->env_id;
+	e->env_ipc_value = value;
+	e->env_status = ENV_RUNNABLE;
+	return 0;
+
+
+	//panic("sys_ipc_try_send not implemented");
 }
 
 // Block until a value is ready.  Record that you want to receive
@@ -259,18 +415,22 @@ static int
 sys_ipc_recv(void *dstva)
 {
 	// LAB 4: Your code here.
-	panic("sys_ipc_recv not implemented");
+	if( (dstva < (void*)UTOP) && (((int)dstva % PGSIZE) != 0) )
+		return -E_INVAL;
+	curenv->env_ipc_recving = true;
+	curenv->env_status = ENV_NOT_RUNNABLE;
+	curenv->env_ipc_dstva = dstva;
 	return 0;
 }
 
 // Dispatches to the correct kernel function, passing the arguments.
 int32_t
-syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
+syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5, bool protect)
 {
 	// Call the function corresponding to the 'syscallno' parameter.
 	// Return any appropriate return value.
 	// LAB 3: Your code here.
-	int ret = 0;
+	int ret = 0;	
 	switch (syscallno) {
 	case SYS_cputs:
 		sys_cputs((char *) a1, a2);
@@ -286,6 +446,37 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 		sys_env_destroy(a1);
 		ret = 0;
 		break;
+	case SYS_exofork:
+		ret = sys_exofork();
+		break;
+	case SYS_page_alloc:
+		ret = sys_page_alloc((envid_t) a1, (void*) a2, (int32_t) a3);
+		break;
+	case SYS_env_set_status:
+		ret = sys_env_set_status( (envid_t) a1, (int32_t) a2);
+		int prueba = ret;
+		break;
+	case SYS_page_map:
+		ret = sys_page_map((envid_t) a1, (void*) a2, (envid_t) a3, (void*) a4, (int32_t)a5, protect);
+		break;
+	case SYS_page_unmap:
+		ret = sys_page_unmap( (envid_t) a1, (void*) a2);
+		break;
+	case SYS_ipc_try_send:
+		ret = sys_ipc_try_send(a1, a2, (void*)a3, a4);
+		break;
+		//sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
+	case SYS_ipc_recv:
+		ret = sys_ipc_recv((void*)a1);
+		break;
+		//sys_ipc_recv(void *dstva)
+	case SYS_env_set_pgfault_upcall:
+		ret = sys_env_set_pgfault_upcall( (envid_t) a1, (void*) a2);
+		break;
+	case SYS_yield:
+		sys_yield();
+		break;
+
 	default:
 		ret = -E_INVAL;
 	}
diff --git a/kern/syscall.h b/kern/syscall.h
index e370801..4d44da6 100644
--- a/kern/syscall.h
+++ b/kern/syscall.h
@@ -6,6 +6,6 @@
 
 #include <inc/syscall.h>
 
-int32_t syscall(uint32_t num, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5);
+int32_t syscall(uint32_t num, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5, bool protect);
 
 #endif /* !JOS_KERN_SYSCALL_H */
diff --git a/kern/trap.c b/kern/trap.c
index 6c47a98..94bf651 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -14,7 +14,7 @@
 #include <kern/cpu.h>
 #include <kern/spinlock.h>
 
-static struct Taskstate ts;
+// tatic struct Taskstate ts;
 
 /* For debugging, so print_trapframe can distinguish between printing
  * a saved trapframe and printing the current trapframe and print some
@@ -92,6 +92,7 @@ trap_init(void)
 	void trap_handler_18();
 	void trap_handler_19();
 	void trap_handler_20();
+	void trap_handler_32();
 	void trap_handler_48();
 
 	SETGATE(idt[0], 0, GD_KT, trap_handler_0, 0);
@@ -119,6 +120,10 @@ trap_init(void)
 	SETGATE(idt[18], 0, GD_KT, trap_handler_18, 0);
 	SETGATE(idt[19], 0, GD_KT, trap_handler_19, 0);
 	SETGATE(idt[20], 0, GD_KT, trap_handler_20, 0);
+
+	//IRQ_TIMER
+	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], 0, GD_KT, trap_handler_32, 0);
+
 	SETGATE(idt[48], 0, GD_KT, trap_handler_48, 3);
 
 
@@ -155,18 +160,27 @@ trap_init_percpu(void)
 
 	// Setup a TSS so that we get the right stack
 	// when we trap to the kernel.
-	ts.ts_esp0 = KSTACKTOP;
-	ts.ts_ss0 = GD_KD;
-	ts.ts_iomb = sizeof(struct Taskstate);
+
+	int id = cpunum();
+	struct CpuInfo *cpu = &cpus[id];
+	struct Taskstate *ts = &cpu->cpu_ts;
+
+	uintptr_t ts_stack = (KSTACKTOP) - id * (KSTKSIZE + KSTKGAP);
+
+	ts->ts_esp0 = ts_stack;
+	ts->ts_ss0 = GD_KD;
+	ts->ts_iomb = sizeof(struct Taskstate);
 
 	// Initialize the TSS slot of the gdt.
-	gdt[GD_TSS0 >> 3] =
-	        SEG16(STS_T32A, (uint32_t)(&ts), sizeof(struct Taskstate) - 1, 0);
-	gdt[GD_TSS0 >> 3].sd_s = 0;
+	uint16_t idx = (GD_TSS0 >> 3) + id;
+	gdt[idx] =
+	        SEG16(STS_T32A, (uint32_t)(ts), sizeof(struct Taskstate) - 1, 0);
+	gdt[idx].sd_s = 0;
 
 	// Load the TSS selector (like other segment selectors, the
 	// bottom three bits are special; we leave them 0)
-	ltr(GD_TSS0);
+	uint16_t seg = idx << 3;
+	ltr(seg);
 
 	// Load the IDT
 	lidt(&idt_pd);
@@ -238,7 +252,7 @@ trap_dispatch(struct Trapframe *tf)
 		                              tf->tf_regs.reg_ecx,
 		                              tf->tf_regs.reg_ebx,
 		                              tf->tf_regs.reg_edi,
-		                              tf->tf_regs.reg_esi);
+		                              tf->tf_regs.reg_esi, 1);
 		return;
 	}
 
@@ -255,6 +269,11 @@ trap_dispatch(struct Trapframe *tf)
 	// Handle clock interrupts. Don't forget to acknowledge the
 	// interrupt using lapic_eoi() before calling the scheduler!
 	// LAB 4: Your code here.
+	if ( (tf->tf_eflags & FL_IF) == FL_IF) {
+		// cprintf("Estoy en FL_IF");
+		lapic_eoi();
+		sched_yield();
+	}
 
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
@@ -292,6 +311,7 @@ trap(struct Trapframe *tf)
 		// Acquire the big kernel lock before doing any
 		// serious kernel work.
 		// LAB 4: Your code here.
+		lock_kernel();
 		assert(curenv);
 
 		// Garbage collect if current enviroment is a zombie
@@ -372,11 +392,44 @@ page_fault_handler(struct Trapframe *tf)
 
 	// LAB 4: Your code here.
 
-	// Destroy the environment that caused the fault.
+	//cprintf("Ojo porque llegué a trap.c");
+
+	if (curenv->env_pgfault_upcall) {
+		struct UTrapframe *u;
+		uintptr_t topeStack;
+
+
+		if (UXSTACKTOP-PGSIZE<=tf->tf_esp && tf->tf_esp<=UXSTACKTOP-1)
+			topeStack = tf->tf_esp - sizeof(struct UTrapframe) - 4;
+		else 
+			topeStack = UXSTACKTOP - sizeof(struct UTrapframe);
+
+		user_mem_assert(curenv, (void*)topeStack, 1, 0);
+
+		u = (struct UTrapframe *) topeStack;
+
+		u->utf_fault_va = fault_va;
+		u->utf_err = tf->tf_err;
+		u->utf_regs = tf->tf_regs;
+		u->utf_eip = tf->tf_eip;
+		u->utf_eflags = tf->tf_eflags;
+		u->utf_esp = tf->tf_esp;
+
+		curenv->env_tf.tf_eip = (uintptr_t)curenv->env_pgfault_upcall;
+		curenv->env_tf.tf_esp = topeStack;
+		env_run(curenv);
+	}
+	
+	//Destroy the environment that caused the fault.
 	cprintf("[%08x] user fault va %08x ip %08x\n",
-	        curenv->env_id,
-	        fault_va,
-	        tf->tf_eip);
+		curenv->env_id,
+		fault_va,
+		tf->tf_eip);
 	print_trapframe(tf);
 	env_destroy(curenv);
+	
+
+
+
+
 }
diff --git a/kern/trapentry.S b/kern/trapentry.S
index bf2223b..38beb58 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -72,6 +72,8 @@ TRAPHANDLER_NOEC(trap_handler_18, 18);
 TRAPHANDLER_NOEC(trap_handler_19, 19);
 TRAPHANDLER_NOEC(trap_handler_20, 20);
 
+//IRQ TIMER
+TRAPHANDLER_NOEC(trap_handler_32, 32);
 TRAPHANDLER_NOEC(trap_handler_48, 48);
 /*
  * Lab 3: Your code here for _alltraps
diff --git a/lab5 b/lab5
new file mode 100644
index 0000000..ce7bdf1
--- /dev/null
+++ b/lab5
@@ -0,0 +1,36 @@
+LAB 5:
+
+Para leer un bloque entero, tengo que leer 8 sectores
+
+En jos un bloque tiene 4096 bytes
+
+
+En el bloque 0 del dico va el boot sector. En el caso de tener varios discos no hace falta que todos tengan cargado el boot sector ahi, por lo tanto solamente uno lo tiene cargado y los otros discos lo dejan vacio, es decir que no lo usan para otra cosa.
+
+El bloque 1 tiene el sistema operativo.
+
+
+
+
+
+
+
+Particularmente en jOS:
+
+No hay inodos
+
+Un directorio es una secuencia de "struct File"
+
+Un struct es 256 bytes. Un directorio se compone de struct files.
+
+El FILE es solo data
+
+
+Para un archivo se guarda toda la metadata en un struct file, entonces para un archivo buscamos este struct file y este tiene la informacion de en que bloques se guarda la info de este archivo. Cada bloque esta dividido en structs de 256.
+
+
+Un strcut file tiene punteros directos y punteros indirectos (para usar niveles de indireccion) como en la teoria del arpachi
+
+
+
+
diff --git a/lib/fork.c b/lib/fork.c
index d32749e..4fff88a 100644
--- a/lib/fork.c
+++ b/lib/fork.c
@@ -26,6 +26,13 @@ pgfault(struct UTrapframe *utf)
 
 	// LAB 4: Your code here.
 
+	int perm = uvpt[PGNUM(addr)];
+
+	cprintf("Pasé por acá con dir %x y perm %x \n", addr, perm);
+
+	if( (!(err & FEC_PR)) || (!(err & FEC_WR)) || (!(perm & PTE_COW)) )
+		panic("Pgfault accedida en condiciones anómalas\n");
+
 	// Allocate a new page, map it at a temporary location (PFTEMP),
 	// copy the data from the old page to the new page, then move the new
 	// page to the old page's address.
@@ -34,7 +41,16 @@ pgfault(struct UTrapframe *utf)
 
 	// LAB 4: Your code here.
 
-	panic("pgfault not implemented");
+	addr = ROUNDDOWN(addr, PGSIZE);
+	if( (r = sys_page_alloc(0, PFTEMP, PTE_W|PTE_U|PTE_P)) <0) 
+		panic("Pgfault allocating error\n");
+	memmove(PFTEMP, addr, PGSIZE);
+
+	if( (r = sys_page_map(0, PFTEMP, 0, addr, PTE_W|PTE_U|PTE_P)) < 0 )
+		panic("Pgfault mapping error \n");
+	if( (r = sys_page_unmap(0, PFTEMP)) < 0)
+		panic("Pgfault unmapping error\n");
+
 }
 
 //
@@ -52,12 +68,84 @@ static int
 duppage(envid_t envid, unsigned pn)
 {
 	int r;
-
 	// LAB 4: Your code here.
-	panic("duppage not implemented");
+	//panic("duppage not implemented");
+	//return 0;
+
+	void* va = (void*) (pn * PGSIZE);
+
+	int perm = (uvpt[pn] & PTE_SYSCALL);
+
+	if(perm & PTE_W || perm & PTE_COW)
+	{
+		perm = (perm & (~PTE_W)) | PTE_COW;
+		if( (r = sys_page_map(0, va, envid, va, perm)) < 0)
+			panic("sys_page_map: %e", r);
+
+		if( (r = sys_page_map(0, va, 0, va, perm)) < 0)
+
+			panic("sys_page_map: %e", r);
+	}
+	else
+	{
+		if( (r = sys_page_map(0, va, envid, va, perm)) < 0)
+			panic("sys_page_map: %e", r);
+	}
+
+	
 	return 0;
 }
 
+static void
+dup_or_share(envid_t dstenv, void *va, int perm)
+{
+	int r;
+
+	if( perm & PTE_W )
+	{
+		if ((r = sys_page_alloc(dstenv, va, perm)) < 0)
+		panic("sys_page_alloc: %e", r);
+	}
+	if ((r = sys_page_map(dstenv, va, 0, UTEMP, perm)) < 0)
+		panic("sys_page_map: %e", r);
+	memmove(UTEMP, va, PGSIZE);
+	if ((r = sys_page_unmap(0, UTEMP)) < 0)
+		panic("sys_page_unmap: %e", r);
+	
+}
+
+
+envid_t fork_v0(void)
+{
+	envid_t envid;
+
+	envid = sys_exofork();
+	if(envid < 0)
+	{
+		panic("sys_exofork: %e", envid);
+	}
+	if(envid == 0) //Hijo
+	{
+
+		thisenv = &envs[ENVX(sys_getenvid())];
+		return 0;
+	}
+
+	//Padre
+	uint32_t va;
+	for(va = 0; va < UTOP; va += PGSIZE)
+	{
+		if( (uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_U) )
+			dup_or_share(envid, (void*) va, uvpt[PGNUM(va)] & PTE_SYSCALL);
+	}
+
+	// Start the child environment running
+	if( sys_env_set_status(envid, ENV_RUNNABLE) < 0) 
+		panic("sys_env_set_status");
+	
+	return envid;
+}
+
 //
 // User-level fork with copy-on-write.
 // Set up our page fault handler appropriately.
@@ -77,10 +165,53 @@ duppage(envid_t envid, unsigned pn)
 envid_t
 fork(void)
 {
-	// LAB 4: Your code here.
-	panic("fork not implemented");
+	//return fork_v0();
+	// panic("fork not implemented");
+
+	envid_t envid;
+	set_pgfault_handler( (void*) pgfault);
+
+	envid = sys_exofork();
+	if(envid < 0)
+		panic("sys_exofork: %e", envid);
+
+	if(envid == 0) {  //Hijo 
+		cprintf("Estoy en el hije\n");
+		thisenv = &envs[ENVX(sys_getenvid())];
+
+
+		return 0;
+	}
+
+	uint32_t va;
+	uint32_t PTE_P_U = PTE_P | PTE_U;
+	for(va = 0; va < UTOP; va += PGSIZE)
+	{
+		if ( (UXSTACKTOP-PGSIZE)<=va && va<=(UXSTACKTOP-1) )
+			continue;		// el stack de excepciones no se mapea.
+
+
+		if( (uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & (PTE_P_U)) )
+			duppage(envid, PGNUM(va));
+
+		//cprintf("Otra iteración %x \n", va);
+	}
+
+	if( sys_page_alloc(envid, (void*) UXSTACKTOP - PGSIZE, PTE_U|PTE_W|PTE_P) < 0)
+			panic("Falló sys_page_alloc en set_pgfault_handler");
+
+	extern void _pgfault_upcall();
+	sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
+
+	// Start the child environment running
+	if( sys_env_set_status(envid, ENV_RUNNABLE) < 0) 
+		panic("sys_env_set_status");
+
+
+	return envid;
 }
 
+
 // Challenge!
 int
 sfork(void)
diff --git a/lib/ipc.c b/lib/ipc.c
index 2e222b9..d0ddae5 100644
--- a/lib/ipc.c
+++ b/lib/ipc.c
@@ -23,8 +23,30 @@ int32_t
 ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
 {
 	// LAB 4: Your code here.
-	panic("ipc_recv not implemented");
-	return 0;
+	int r;
+
+	if(pg != NULL)
+		r = sys_ipc_recv(pg);
+	else
+		r = sys_ipc_recv((void*)UTOP);
+
+	if(r < 0)
+	{
+		if(from_env_store != NULL)
+			*from_env_store = 0;
+
+		if(perm_store != NULL)
+			*perm_store = 0;
+		return r;
+	}
+
+	if(from_env_store != NULL)
+		*from_env_store = thisenv->env_ipc_from;
+
+	if(perm_store != NULL)
+		*perm_store = thisenv->env_ipc_perm;
+
+	return thisenv->env_ipc_value;
 }
 
 // Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.
@@ -39,7 +61,25 @@ void
 ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
 {
 	// LAB 4: Your code here.
-	panic("ipc_send not implemented");
+	int r;
+
+	do{
+		if(pg != NULL)
+		{
+			r = sys_ipc_try_send(to_env, val, pg, perm);
+		}
+		else
+		{
+			r = sys_ipc_try_send(to_env, val, (void*)UTOP, perm);
+		}
+
+		//printf("VALOR R: %d", r);
+		if( (r < 0) && (r != -E_IPC_NOT_RECV) )
+			panic("El error NO es -E_IPC_NOT_RECV, es %d", r);
+
+		sys_yield();
+	}while(r != 0);
+
 }
 
 // Find the first environment of the given type.  We'll use this to
diff --git a/lib/pfentry.S b/lib/pfentry.S
index f40aeeb..cb5fdca 100644
--- a/lib/pfentry.S
+++ b/lib/pfentry.S
@@ -8,7 +8,7 @@
 // in pgfault.c).
 //
 // When a page fault actually occurs, the kernel switches our ESP to
-// point to the user exception stack if we're not already on the user
+// point to the user exception stack if were not already on the user
 // exception stack, and then it pushes a UTrapframe onto our user
 // exception stack:
 //
@@ -45,18 +45,18 @@ _pgfault_upcall:
 	// Explanation:
 	//   We must prepare the trap-time stack for our eventual return to
 	//   re-execute the instruction that faulted.
-	//   Unfortunately, we can't return directly from the exception stack:
-	//   We can't call 'jmp', since that requires that we load the address
+	//   Unfortunately, we cant return directly from the exception stack:
+	//   We cant call jmp, since that requires that we load the address
 	//   into a register, and all registers must have their trap-time
 	//   values after the return.
-	//   We can't call 'ret' from the exception stack either, since if we
+	//   We cant call ret from the exception stack either, since if we
 	//   did, %esp would have the wrong value.
 	//   So instead, we push the trap-time %eip onto the *trap-time* stack!
-	//   Below we'll switch to that stack and call 'ret', which will
+	//   Below well switch to that stack and call ret, which will
 	//   restore %eip to its pre-fault value.
 	//
 	//   In the case of a recursive fault on the exception stack,
-	//   note that the word we're pushing now will fit in the
+	//   note that the word we are pushing now will fit in the
 	//   blank word that the kernel reserved for us.
 	//
 	// Throughout the remaining code, think carefully about what
@@ -65,18 +65,34 @@ _pgfault_upcall:
 	// ways as registers become unavailable as scratch space.
 	//
 	// LAB 4: Your code here.
+	movl 0x28(%esp), %edx 
+	subl $0x4, 0x30(%esp) 
+	movl 0x30(%esp), %eax
+	movl %edx, (%eax)
+	addl $0x8, %esp
+
 
 	// Restore the trap-time registers.  After you do this, you
 	// can no longer modify any general-purpose registers.
 	// LAB 4: Your code here.
 
+	popal						// hago pop de los reg de prop general
+
 	// Restore eflags from the stack.  After you do this, you can
 	// no longer use arithmetic operations or anything else that
 	// modifies eflags.
 	// LAB 4: Your code here.
 
+	addl $0x4, %esp #eip
+	popfl
+
 	// Switch back to the adjusted trap-time stack.
 	// LAB 4: Your code here.
 
+	popl %esp 					// restauro %esp
+
 	// Return to re-execute the instruction that faulted.
 	// LAB 4: Your code here.
+
+	ret
+
diff --git a/lib/pgfault.c b/lib/pgfault.c
index a975518..6aef99b 100644
--- a/lib/pgfault.c
+++ b/lib/pgfault.c
@@ -13,7 +13,6 @@ extern void _pgfault_upcall(void);
 // Pointer to currently installed C-language pgfault handler.
 void (*_pgfault_handler)(struct UTrapframe *utf);
 
-//
 // Set the page fault handler function.
 // If there isn't one yet, _pgfault_handler will be 0.
 // The first time we register a handler, we need to
@@ -29,9 +28,18 @@ set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
 	if (_pgfault_handler == 0) {
 		// First time through!
 		// LAB 4: Your code here.
-		panic("set_pgfault_handler not implemented");
+		//panic("set_pgfault_handler not implemented");
+
+		if( sys_page_alloc(0, (void*) UXSTACKTOP - PGSIZE, PTE_SYSCALL) < 0)
+			panic("Falló sys_page_alloc en set_pgfault_handler");
+		
 	}
 
 	// Save handler pointer for assembly to call.
 	_pgfault_handler = handler;
+
+	//Para mi esto va despues de asignarle a _pagfault_handler
+	if( sys_env_set_pgfault_upcall(0, _pgfault_upcall) < 0)
+			panic("Falló sys_env_set_pgfault_upcall en set_pgfault_handler");
+
 }
diff --git a/user/dumbfork.c b/user/dumbfork.c
index e5e433c..6442da2 100644
--- a/user/dumbfork.c
+++ b/user/dumbfork.c
@@ -18,6 +18,8 @@ umain(int argc, char **argv)
 	// print a message and yield to the other a few times
 	for (i = 0; i < (who ? 10 : 20); i++) {
 		cprintf("%d: I am the %s!\n", i, who ? "parent" : "child");
+		int32_t id = (int32_t) sys_getenvid();
+		cprintf("El envid es %d\n", id);
 		sys_yield();
 	}
 }
diff --git a/user/yield.c b/user/yield.c
index 6f45bdb..ed7ea16 100644
--- a/user/yield.c
+++ b/user/yield.c
@@ -7,11 +7,11 @@ umain(int argc, char **argv)
 {
 	int i;
 
-	cprintf("Hello, I am environment %08x.\n", thisenv->env_id);
+	cprintf("Hello, I am environment %08x, cpu %d\n", thisenv->env_id, thisenv->env_cpunum);
 	for (i = 0; i < 5; i++) {
 		sys_yield();
-		cprintf("Back in environment %08x, iteration %d.\n",
-			thisenv->env_id, i);
+		cprintf("Back in environment %08x, iteration %d, cpu %d\n",
+			thisenv->env_id, i, thisenv->env_cpunum);
 	}
 	cprintf("All done in environment %08x.\n", thisenv->env_id);
 }
